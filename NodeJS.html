<html>
<head>
  <title>NodeJS</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/303788 (zh-CN, DDL); Windows/6.2.9200 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="1181"/>
<h1>NodeJS</h1>

<div>
<span><div>JS运行在浏览器内核，浏览器内核中有JS引擎和标签渲染引擎---本质上是运行在JS引擎</div><div>-----&gt;只要有JS引擎，JS就可以运行在哪里，包括服务器端----&gt;NodeJS</div><div>NodeJS不存在BOM和DOM,提供了操作系统的底层API，实现了服务器端的编程，包括：文件操作，进程操作，通信操作等</div><div><img src="NodeJS_files/Image.png" type="image/png" style="height: auto;"/></div><div><br/></div><div><img src="NodeJS_files/Image [1].png" type="image/png" style="height: auto;"/></div><div>Node.js程序运行方式之一：REPL（read-eval-print-loop）</div><div>- 在命令行窗口中 _表示当前计算的表达式的结果</div><div>- 两次 ctrl+c 可以退出REPL模式，或者执行 .exit 命令</div><div>- Node.js程序运行方式之二：运行js文件（ node 文件名称）</div><div>- Node.js中不可以进行DOM和BOM操作</div><div>nodeJS运行程序的方式:REPL</div><div>命令行窗口中，-代表当前计算的表达式结果</div><div>两次Ctrl+c可以退出REPL模式，或执行.exit命令</div><div>node.js中不可以进行dom和bom操作</div><div><br/></div><div><img src="NodeJS_files/Image [2].png" type="image/png" style="height: auto;"/></div><div><br/></div><div><span style="color: rgb(51, 51, 51); font-family: Helvetica, arial, &quot;microsoft yahei&quot;, simhei; font-size: 15px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: normal; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; display: inline !important; float: none;">process对象用于处理与当前进程相关的事情，它是一个全局对象，可以在任何地方直接访问到它而无需引入额外模块。 </span></div><div><span style="font-size: 15px;"><span style="font-family: Helvetica, arial, 'microsoft yahei', simhei;"><span style="color: rgb(51, 51, 51);"><br/></span></span></span></div><div>使用require可以导入成员，require引入多次模块实际上不会加载多次，因为第一次已经缓存了</div><div>通过global也可以公开成员，这个时候在其他模块导入含有使用global公开成员的模块时就不需要使用变量去接收了，直接require（地址）</div><div><br/></div><div>exports 和 module.exports 的区别：</div><ol><li>module.exports 初始值为一个空对象 {}</li><li>exports 是指向的 module.exports 的引用</li><li>require() 返回的是 module.exports 而不是 exports</li><li>一般导出单个成员用exports,导出构造函数或者对象的时候使用module.exports</li></ol><div><br/></div><div>package.json是什么？</div><div>1、相当于你本地项目的一个文档说明。</div><div>2、允许你指定你项目中所使用的node包的版本。</div><div>3、构建你的项目更加容易，便于给其他人共享，不需要拷贝整个项目，把package.json拿来执行npm install命令即可</div><div><br/></div><div>使用npm生成package.json：</div><div>npm  init---初始化npm,即可npm生成package.json</div><div>或者 npm init -y  ----所有参数全部按照默认参数设置</div><div>使用npm install ** --save会生成dependencies依赖---上线时需要的依赖</div><div>使用npm install ** --save-dev会生成devDependencies依赖---开发测试的依赖</div><div><br/></div><div><br/></div><div><img src="NodeJS_files/Image [3].png" type="image/png" style="height: auto;"/></div><div><br/></div><div><img src="NodeJS_files/Image [4].png" type="image/png" style="height: auto;"/></div><div><br/></div><div><br/></div><div><img src="NodeJS_files/Image [5].png" type="image/png" style="height: auto;"/></div><div>es6语法：</div><div>let声明的变量不存在预解析</div><div>let声明的变量是在块级作用域有效</div><div>let声明的变量同一块级作用域中只能声明一次</div><div>存在块级作用域</div><div>块级作用域中存在暂时性死区---不可以声明变量之前使用</div><div>const声明的变量不可重新赋值（他是一个常量），必须在声明的时候进行初始化</div><div>获取数组长度：let{length}='hello';</div><div>----&gt;或者：</div><div>let{length：i}='hello';</div><div>console.log(i);</div><div>解构赋值：</div><div>字符串扩展：</div><div><img src="NodeJS_files/Image [6].png" type="image/png" style="height: auto;"/></div><div><br/></div><div>拼接字符串：</div><div>1.传统方式</div><div>2.反引号内使用${XXX}--里面是对数据的引用</div><div><img src="NodeJS_files/Image [7].png" type="image/png" style="height: auto;"/></div><div>函数声明括号里的参数是默认值，调用函数的时候不赋值默认使用这个默认参数，传参则会覆盖默认值</div><div>rest参数</div><div>扩展运算符 ...</div><div>foo（...data）----... ---以函数的形参形式把传进去的剩下的实参转换为数组形式</div><div>...arr------...把实际的数据转换成单个数据项</div><div>apply----把数组或者类数组转换成单个数据项</div><div>foo.applyl(null,arr)</div><div>箭头函数：相当于匿名函数，单个语句省略{}和return，多语句不能省略，箭头前的变量就是形参</div><div>1.单条语句：</div><div style="margin: 15px 0px; padding: 10px; background: rgb(250, 250, 250); font-style: normal; font-variant: normal; font-weight: normal; font-stretch: normal; font-size: 12px; font-family: Consolas, monospace, serif; color: rgb(68, 68, 68); tab-size: 4; overflow: auto; border: 1px solid rgb(221, 221, 221); border-radius: 3px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><code>x =&gt; x * x</code></div><div>相当于：</div><div style="margin: 15px 0px; padding: 10px; background: rgb(250, 250, 250); font-style: normal; font-variant: normal; font-weight: normal; font-stretch: normal; font-size: 12px; font-family: Consolas, monospace, serif; color: rgb(68, 68, 68); tab-size: 4; overflow: auto; border: 1px solid rgb(221, 221, 221); border-radius: 3px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><code><span style="color: rgb(51, 51, 51); font-weight: bold;">function</span> (x) {<br/>
    <span style="color: rgb(51, 51, 51); font-weight: bold;">return</span> x * x;</code><div>}</div></div><div>2.多条语句：</div><div><br/></div><div>单个参数：</div><div style="margin: 15px 0px; padding: 10px; background-color: rgb(250, 250, 250); font-style: normal; font-variant: normal; font-weight: normal; tab-size: 4; overflow: auto; border: 1px solid rgb(221, 221, 221); border-top-left-radius: 3px; border-top-right-radius: 3px; border-bottom-right-radius: 3px; border-bottom-left-radius: 3px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-position: initial initial; background-repeat: initial initial;"><span style="font-size: 12px;"><span style="font-family: Consolas, monospace, serif;"><span style="color: rgb(68, 68, 68);"><code>x =&gt; {<br/>
    <span style="color: rgb(51, 51, 51); font-weight: bold;">if</span> (x &gt; <span style="color: rgb(0, 153, 153);">0</span>) {<br/>
        <span style="color: rgb(51, 51, 51); font-weight: bold;">return</span> x * x;<br/>
    }<br/>
    <span style="color: rgb(51, 51, 51); font-weight: bold;">else</span> {<br/>
        <span style="color: rgb(51, 51, 51); font-weight: bold;">return</span> - x * x;<br/>
    }</code></span></span></span><div><span style="font-size: 12px;"><span style="font-family: Consolas, monospace, serif;"><span style="color: rgb(68, 68, 68);">}</span></span></span></div></div><div style="margin: 15px 0px; font-style: normal; font-weight: normal; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><div>如果参数不是一个，就需要用括号()括起来：</div></div><div style="margin: 15px 0px; padding: 10px; background: rgb(250, 250, 250); font-style: normal; font-variant: normal; font-weight: normal; font-stretch: normal; font-size: 12px; font-family: Consolas, monospace, serif; color: rgb(68, 68, 68); tab-size: 4; overflow: auto; border: 1px solid rgb(221, 221, 221); border-radius: 3px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><code><span style="color: rgb(153, 153, 136); font-style: italic;">// 两个参数:</span><br/>
(x, y) =&gt; x * x + y * y<br/><br/><span style="color: rgb(153, 153, 136); font-style: italic;">// 无参数:</span><br/>
() =&gt; <span style="color: rgb(0, 153, 153);">3.14</span><br/><br/><span style="color: rgb(153, 153, 136); font-style: italic;">// 可变参数:</span><br/>
(x, y, ...rest) =&gt; {<br/>
    <span style="color: rgb(51, 51, 51); font-weight: bold;">var</span> i, sum = x + y;<br/>
    <span style="color: rgb(51, 51, 51); font-weight: bold;">for</span> (i=<span style="color: rgb(0, 153, 153);">0</span>; i&lt;rest.length; i++) {<br/>
        sum += rest[i];<br/>
    }<br/>
    <span style="color: rgb(51, 51, 51); font-weight: bold;">return</span> sum;<br/>
}</code></div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>arr.forEach((e,i)=&gt;{</div><div>    console.log(e,i);</div><div>})</div></div><div><br/></div><div>如果要返回一个对象，为了避免和函数体的语法冲突，要给对象外面包个括号，而不是{}：</div><div style="margin: 15px 0px; padding: 10px; background: rgb(250, 250, 250); font-style: normal; font-variant: normal; font-weight: normal; font-stretch: normal; font-size: 12px; font-family: Consolas, monospace, serif; color: rgb(68, 68, 68); tab-size: 4; overflow: auto; border: 1px solid rgb(221, 221, 221); border-radius: 3px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><div><code>x =&gt; ({ foo: x })</code></div></div><div>这样写是错误的：</div><div style="margin: 15px 0px; padding: 10px; background: rgb(250, 250, 250); font-style: normal; font-variant: normal; font-weight: normal; font-stretch: normal; font-size: 12px; font-family: Consolas, monospace, serif; color: rgb(68, 68, 68); tab-size: 4; overflow: auto; border: 1px solid rgb(221, 221, 221); border-radius: 3px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><code>x =&gt; { foo: x }</code></div><div>箭头函数this的指向：</div><div>和匿名函数不同，匿名函数赋值给某变量以后构成函数表达式之后this是由调用他的那个对象确定的，但是对于箭头函数来说，它本身是没有this的，只不过强制性的把this绑定给了词法作用域，也就是定义时所处的对象</div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>function foo(){</div><div>    setTimeout(() =&gt; {</div><div>        console.log(this.num);</div><div>    },100);</div><div>}</div><div>let num = 1;</div><div>foo.call({num:3});</div></div><div>这里因为将foo的this人为的指向了这个对象，所以当前函数是在这个对象环境中执行的，所以这个箭头函数的词法作用域就相当于在这个对象里，也就是说，他是在这个对象中定义的，this指向他定义时的对象</div><div><br/></div><div>ECMAscript6基础语法：</div><div>类--本质就是构造函数</div><div>静态方法要通过类来使用</div><div><br/></div><div>Buffer---可以生成16进制数据的类,用来操作字节流,数据缓冲区</div><div>实例化：</div><div>new Buffer---已经不推荐使用</div><div>Buffer.from('abc')</div><div>  </div><div>Buffer.alloc(5)---分配空间</div><div><br/></div><div><br/></div><div>异步编程模式：----node.js中的常用编程方式</div><div><br/></div><div>浏览器中的异步操作：</div><div>1.定时函数</div><div>2.事件函数</div><div>3.ajax回调函数</div><div><br/></div><div>---只有其他主线任务处理完之后，才会开始处理事件队列中的任务，不会阻塞任务执行</div><div>---触发相应函数才会从事件队列中取出,放到主线程中再次执行</div><div><br/></div><div>为什么会有异步？</div><div>js运行模式：单线程----易阻塞，效率低</div><div>解决方式：异步模式---单线程+事件队列模式</div><div><br/></div><div>异步任务触发条件：</div><div>1、主线程空闲</div><div>2、满足任务的触发条件</div><div><br/></div><div>fs--文件系统模块</div><div>fs.stat（path,callback）---异步获取文件信息</div><div>fs.statSync（path,callback ）----通步获取文件信息</div><div><br/></div><div>文件存在性判断：</div><div>fs.exists（path,callback）</div><div><br/></div></span>
</div></body></html> 