<html>
<head>
  <title>第四天 预解析</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/303788 (zh-CN, DDL); Windows/6.2.9200 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="734"/>
<h1>第四天 预解析</h1>

<div>
<span><div style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:0.00mm; margin-bottom:3.52mm;"><div><b><font color="#2E74B5" face="Calibri Light" size="4"><span style="font-size:14pt"><b>1.</b></span></font><font color="#2E74B5" face="宋体" size="4"><span style="font-size:14pt">预解析</span></font></b></div></div><div><font color="#010101" face="微软雅黑" size="2"><span style="font-size:10pt">a.编译型语言:</span></font><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:0.00mm; margin-bottom:3.52mm;"><font color="#010101" face="Calibri"><span style="font-size:11pt">               C, C++, C#, Java  ----</span></font><font color="#010101">提前翻译好</font><font color="#010101">,</font> <font color="#010101">运行时直接执行得结果</font></p></div><div>b.解释型( 脚本型 ):</div><div>                JavaScript, SQL, ...----边解析，边执行</div><div>          预解析：</div><div>          代码在执行的时候, 有一个翻译程序, 读一句代码执行一句代码. 再读一句代码,</div><div>          再执行一句代码.  每次运行都需要翻译一次.</div><div>          特点：</div><div>          a.js代码执行之前一定要进行一次预解析</div><div>          b.js 在预解析的过程中完成了声明部分的标记与变量作用域的设定</div><div><br/></div><div style="font-weight: bold; font-size: 26px;"><font color="#2E74B5" face="Calibri Light" size="4"><span style="font-size:14pt"><b>2.js</b></span></font><font color="#2E74B5" face="宋体" size="4"><span style="font-size:14pt"><b>中的声明</b></span></font></div><div><font color="#010101" face="微软雅黑" size="2"><span style="font-size:10pt"><i><span style="font-size: 15px;"><b><span style="color: rgb(235, 0, 115);">目的：</span></b></span></i>预解析的时候是为了让js执行引擎知道当前运行环境中哪些名字，标识符等可以使用，哪些是函数，哪些是变量 （你告诉他有就有，没告诉他就不知道）<span style="color: rgb(65, 173, 28);"><b>---提前扫描</b></span></span></font></div><div>1) 标识符的声明( 变量的声明 )－－－只声明，不赋值（不定义）</div><div>   有多个var，只有第一个生效，其他无效</div><div>2) 函数的声明</div><div>              语法:  var 变量名;</div><div>              目的: 告诉解释器, 有一个名字是一个变量, 在当前环境中可以被使用.</div><div>              语句: 就是可以执行的东西.</div><div>                     var a = 123; 是一个语句</div><div>              在使用 var 声明变量, 同时完成赋值的时候. 实际上, 预解析将其做了一定处理:</div><div>              -&gt; 凡是读取到 var 的时候, 就检查 var 紧跟的名字是否已经标记了</div><div>              -&gt; 如果没有标记, 就表明这个名字是一个标识符, 需要被标记</div><div>              -&gt; 如果已经被标记了, 那么 这个 var 被忽略</div><div><br/></div><div style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:0.00mm; margin-bottom:3.52mm; background: #fbfaf8;"><div style="box-sizing: border-box; padding: 8px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">                     var a;</span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);"><br/></span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">                     var a = 10;</span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);"><br/></span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">                     等价</span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);"><br/></span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">                     var a;</span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);"><br/></span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">                     a = 10;//第二个var无效，只有第一个起作用</span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);"><br/></span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">                     var a = 123;</span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);"><br/></span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">                     var a = 456;</span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);"><br/></span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">                     var a = 789;</span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);"><br/></span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">                     等价于</span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);"><br/></span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">                     var a = 123;</span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);"><br/></span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">                     a = 456;</span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);"><br/></span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">                     a = 789;</span></span></span></div></div></div><div><br/></div><div><b><b><font color="#2E74B5" face="Calibri Light" size="4"><span style="font-size:14pt">3.JS</span></font><font color="#2E74B5" face="宋体" size="4"><span style="font-size:14pt">声明的具体过程</span></font></b></b></div><div><span style="font-size: 13pt;"><span style="color: rgb(112, 173, 71);"><b>变量的提升--</b></span></span>只是一个名词，就是说定义在后面的变量，提前调用，拿到的是undefined;</div><div>-----在当前作用域下的提升</div><div>1.读取所有代码，着重留意var；</div><div>2.判断var是否被标记，已被标记，忽略之，未被标记，标记之；</div><div>3.读取完毕，从头逐行执行代码</div><div><span style="color: rgb(50, 135, 18);"><span style="font-size: 16px;"><b>函数的提升</b></span></span></div><div><span style="color: rgb(26, 144, 185);"> 1.函数的定义</span></div><div>  声明式:   </div><div>                function func () {</div><div>                    console.log( '使用声明式定义' );</div><div>                }</div><div> 表达式式( 匿名函数, 字面量函数, lambda 函数 ):</div><div>                var func = function () {</div><div>                    console.log( '使用表达式式定义' );</div><div>                };</div><div> ...</div><div>特点:</div><div>            1&gt; 函数的声明是独立于语句. 不需要加分号结束. 也不能嵌入到代码表达式中.</div><div>                   function fn(){};</div><div>                    代码执行的时候，声明已在预解析阶段处理完，因此在调试阶段，无法给函数声明添加断点；</div><div>                     可以先调用，后声明，有时开发函数声明全部在后面---为了保证代码紧凑，直接调用</div><div>                    也存在函数名提升</div><div>           </div><div>            2&gt; 表达式式, 本质上是使用函数表达式( 字面量 )给变量赋值. 因此它是语句.</div><div>                  var func = function () { }；</div><div>                   1.读取代码</div><div>                   2.开始执行代码，赋值，将函数值赋给func</div><div>                   3.调用 </div><div>                    先调用会报错：func is not a function</div><div>                    函数表达式也可以有函数名</div><div>                    var 函数名1=function 函数名2（）{}</div><div>                   <img src="第四天 预解析_files/Image.png" type="image/png" style="height: auto;"/></div><div>在函数外部函数的名字是f1,仅此一个</div><div>在函数里面，这个函数的引用有两个，f1和f2</div><div><br/></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">以前的---&gt;</span></div><div>name：（存储的是引用，仅限函数内部使用）</div><div>第一种：</div><div>函数里面调用，可以打印出引用，只打印距离自己最近的那个</div><div>第二种：</div><div>函数外面调用，打印的不是引用，只是函数名称。</div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">现在的---&gt;</span></div><div>name：</div><div>第一种： </div><div>函数里面调用，可以打印出引用，只打印距离自己最近的那个</div><div>第二种：</div><div>函数外面调用，直接打印引用，把函数的引用当做匿名函数的名称来使用（只限表达式为匿名函数的）。</div><div><span style="color: rgb(65, 173, 28);"><b><span style="font-size: 19px;">表达式:</span></b></span>---预解析阶段不提升表达式，自动忽略</div><div>            -&gt; 将运算符与操作数连接起来的式子.</div><div>            -&gt; 就是一个有结果的代码单元( 不包括语句 )</div><div>                var a;        // 声明, 不是语句, 也没有结果</div><div>                123            // 字面量, 有值, 是表达式. 是常量表达式</div><div>                a = 123        // 赋值, 有值, 就是被赋值的那个值. 是赋值表达式.</div><div>                function () {}  //函数表达式，预解析阶段忽略，执行阶段作为值赋给变量</div><div><span style="color: rgb(26, 144, 185);">2.函数的两个阶段：</span></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">定义阶段：</span></div><div>1.开辟一个私有空间；</div><div>2.把函数体内的所有代码当做<b><span style="color: rgb(227, 0, 0);">字符串</span></b>，存入这个私有空间</div><div>3.对函数形参的一个声明（优先级高于预解释）</div><div>4.把这个空间的地址给这个函数的引用</div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">调用阶段：</span></div><div>1.形参赋值</div><div>2.预解释</div><div>3.把地址里存储的字符串拿出来当做JS代码来执行</div><div><i><span style="color: rgb(50, 135, 18);"><b>先形参赋值，再预解释---因为形参已经进行过预解释（在父作用域预解释的时候形参进行声明）</b></span></i></div><div> eg：</div><div>function fn () {}这个样子的函数，是在预解释阶段完成的定义</div><div>var func = function () { };这样的函数不是在预解释阶段完成的定义</div><div><img src="第四天 预解析_files/Image [1].png" type="image/png" style="height: auto;"/></div><div><span style="color: rgb(26, 144, 185);">3.函数的预解释：</span></div><div><span style="color: rgb(0, 0, 0); font-family: 微软雅黑; font-size: medium; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); display: inline !important; float: none;">function fn () {}</span></div><div>预解释阶段做了两件事：（相当于声明+赋值）赋值==定义</div><div>1）.声明变量（告诉浏览器有个变量名叫fn）</div><div>2）.给fn一个地址（告诉浏览器fn是一个函数，可以被调用）</div><div>var fn = function () { }</div><div>预解释阶段只做了一件事：（只声明，赋值在执行阶段）</div><div>1）.声明变量（告诉浏览器有个变量名叫fn ）</div><div>4.将变量声明与函数声明放在一起的情况</div><div>1) 函数的声明实际上包含两部分</div><div>        1&gt; 告诉解释器 xxx 名字已经可以使用( 函数名, 标识符 )</div><div>        2&gt; 告诉解释, 这个名字代表着一个函数( 变量里存储着函数的引用 )</div><div>2) 当函数声明与变量声明冲突的时候. 只看谁先有数据.</div><div><img src="第四天 预解析_files/Image [2].png" type="image/png" style="height: auto;"/></div><div><br/></div><div><img src="第四天 预解析_files/Image [3].png" type="image/png" style="height: auto;"/></div><div><br/></div><div><br/></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">4.预解释的无节操：</span>（IE10之后 ）****（声明+定义）</div><div>1.if语句不管条件是否成立，都会预解释。---对函数声明的无节操</div><div>   函数的定义则是根据if语句的条件来决定的</div><div>   <i><span style="color: rgb(50, 135, 18);"><b>也就是说：在预解析阶段，只是声明函数引用的变量可用，该变量的赋值是在代码的执行阶段；</b></span></i></div><div><i><span style="color: rgb(50, 135, 18);"><b>                    执行阶段，if的条件满足，这个定义阶段才会进行（该变量的赋值），条件不满足，该变量永远是一个空变量。</b></span></i></div><div>     注意：不要在if语句中写声明式的函数，可以写成表达式的函数</div><div>2.自执行函数在预解释阶段不进行预解释，在代码执行阶段，执行到他的时候，声明，定义和调用同时完成</div><div>3.return后的代码虽然不执行，但是会预解释</div><div><img src="第四天 预解析_files/Image [4].png" type="image/png" style="height: auto;"/></div><div><br/></div><div><img src="第四天 预解析_files/Image [5].png" type="image/png" style="height: auto;"/></div><div>5.新浏览器的特性（if）</div><div>     函数在if语句中，不管条件是否成立，都会进行预解释，只不过是都进行了函数的 声明变量阶段 。而函数的定义阶段是根据if语句的条件来进行判断的。</div><div>     注意：不要在if语句中写声明式的函数，可以写表达式式的函数。</div><div><br/></div><div><img src="第四天 预解析_files/Image [6].png" type="image/png" style="height: auto;"/></div><div><br/></div><div>作用域：</div><div>     JS不支持块级作用域</div><div>     在JS中，作用域（除全局作用域外---全局作用域页面打开就有，关闭消失）只能靠函数来决定</div><div>     变量名提升的这个现象在出现函数的时候无效</div><div>     在打开页面的时候进行的第一次预解释不解释函数内的变量和声明（除if，for）</div><div>     在JS中，只有函数可以定义一个私有作用域，可保护内部的变量名不被访问，除非定义全局变量</div><div>     但是里面的作用域可以访问外面的变量</div><div>     函数内部，允许再定义函数，同时两个层次的函数都是作用域的独立体</div><div><img src="第四天 预解析_files/Image [7].png" type="image/png" style="height: auto;"/></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">取值：</span>在函数内部，取值时，现在自己当前作用域内查找有没有该变量名定义可用，如果有就拿来用，提高至查找，如果没有，就向上一级查找（不能跳级），停止查找。。。。直到全局作用域，如果还没有，就报错（is not defined）；--- 优先访问当前作用域</div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">赋值：</span>赋值时，一定是将一个值赋给变量名，先在当前作用域寻找有无该变量名可用，有则赋值，无则去上一级寻找，。。。直到全局作用域，如果还没有，就把这个变量名赋值给全局，直接就可以用</div><div>在函数内的私有作用域是一个完整的作用域结构（所有预解释规则和学过的是一样的）。</div><div>形参：</div><div><img src="第四天 预解析_files/Image [8].png" type="image/png" style="height: auto;"/></div><div><br/></div><div><img src="第四天 预解析_files/Image [9].png" type="image/png" style="height: auto;"/></div><div>        -&gt; 结论:</div><div>            词法作用域就是描述变量的访问范围:</div><div>            1&gt; 在代码中只有函数可以限定作用范围. 允许函数访问外部的变量. 反之不允许.</div><div>            2&gt; 在函数内优先访问内部声明的变量, 如果没有才会访问外部的.</div><div>            3&gt; 所有变量的访问规则, 按照预解析规则来访问</div><div><img src="第四天 预解析_files/Image [10].png" type="image/png" style="height: auto;"/> </div><div><br/></div><div><img src="第四天 预解析_files/Image [11].png" type="image/png" style="height: auto;"/></div><div><br/></div><div><img src="第四天 预解析_files/Image [12].png" type="image/png" style="height: auto;"/></div><div>作用域链：</div><div>概念：</div><div>内部的函数体中访问某一个变量的规则</div><div>注意：只能向上级访问，不能向平级和下级访问；</div><div>          一定是一级级往上找，不能跳级；</div><div><img src="第四天 预解析_files/Image [13].png" type="image/png" style="height: auto;"/></div><div><br/></div><div>两个经典面试题：</div><div><img src="第四天 预解析_files/Image [14].png" type="image/png" style="height: auto;"/></div><div><br/></div><div><img src="第四天 预解析_files/Image [15].png" type="image/png" style="height: auto;"/></div><div><img src="第四天 预解析_files/Image [16].png" type="image/png" style="height: auto;"/></div></span>
</div></body></html> 