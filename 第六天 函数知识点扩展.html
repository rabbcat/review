<html>
<head>
  <title>第六天 函数知识点扩展</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/303788 (zh-CN, DDL); Windows/6.2.9200 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="856"/>
<h1>第六天 函数知识点扩展</h1>

<div>
<span><div><span style="font-size: 21px;"><b><span style="color: rgb(227, 0, 0);">1.函数的四种调用模式</span></b></span></div><div>        1&gt; 函数模式</div><div>        2&gt; 方法模式</div><div>        3&gt; 构造器模式</div><div>        4&gt; 上下文模式</div><div><span style="font-size: 21px;"><span style="color: rgb(227, 0, 0);"><b>2.为什么要学习函数的调用模式</b></span></span>----搞清楚函数里面this的指向问题</div><div>函数定义时和this有什么关系（没关系）；</div><div>函数定义在哪，怎样定义，和函数内部的this没关系；</div><div>this指向问题：函数内部this指向只和函数调用有关系。</div><div><span style="font-size: 16px;"><b><span style="color: rgb(235, 0, 115);">函数调用模式：</span></b></span></div><div>函数名（参数）---前面可以什么也不写，也可以写window，<span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">this指向window</span>，这个时候相当于Window调用了函数</div><div>直接使用函数名调用函数。</div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>function foo () {</div><div>        console.log( '我是一个函数' );</div><div>    }</div><div><br/></div><div> foo();</div></div><div><br/></div><div><span style="font-size: 16px;"><b><span style="color: rgb(235, 0, 115);">方法模式调用：</span></b></span></div><div>对象.函数名()---函数一定是挂在某一个对象上的方法，调用的时候一定是由一个对象引导。</div><div>                      这个时候函数里面的<span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;"> this 指向引导的对象</span></div><div>-&gt; this 表示引导方法的对象 ，调用时一定由一个对象引导--&gt;谁调用他,this就指向谁</div><div>      由对象引导后函数照旧执行</div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>function foo(){</div><div>        console.log( this );</div><div>    }</div><div>      foo();//函数调用</div><div>      var o={name:'jim'};</div><div>      o.fun=foo;</div><div>      o.fun();//方法调用</div><div>    function func () {</div><div>        console.log( '函数也是对象' );</div><div>    }</div><div>    func.fuc=foo;</div><div>    foo();</div><div>    func.fuc();//this指向func函数</div></div><div><br/></div><div><span style="font-size: 16px;"><span style="color: rgb(235, 0, 115);"><b>构造器模式调用：</b></span></span></div><div>使用关键字new引导</div><div>new仅仅是一个运算符，函数前，有new运算符的就是构造模式， <span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">this 指向new出来的这个实例</span>。</div><div>返回值：</div><div>不写return，构造函数默认返回this；</div><div>如果在构造函数中写上 return 语句, 并紧跟基本类型( return num, return 1223 ). 则忽略这个返回类型，仍旧返回this；</div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>    function Person () {</div><div>        this.name = 'jim',</div><div>        this.age = 19;</div><div>        return 123;</div><div>    }</div><div>    var p2 = new Person();//返回this，指当前实例</div><div>    console.log(p2);</div></div><div><br/></div><div>如果在构造函数中写上 return 语句, 并紧跟引用类型(对象，数组等), 那么构造函数返回该引用类型数据, 而忽略 this；</div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>     function Person () {</div><div>        this.name = 'jim',</div><div>        this.age = 19;</div><div>        return { mame:&quot;jim&quot;};</div><div>    }</div><div>    var p2 = new Person();//返回{name：'jim'}</div><div>    console.log(p2);</div></div><div><br/></div><div>-&gt; 如果调用构造函数的时候, 构造函数没有参数, 圆括号是可以省略的</div><div>     <span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">构造函数方式的特点  ：</span></div><div>     1)new Foo---创建实例时，没有传参那可以省略括号；</div><div>     2)出现一个new：</div><div>     new Foo().getName()----使用Foo这个构造函数的实例去调用getName方法</div><div>                                        ---- 写成<span style="color: rgb(0, 0, 0); font-family: 微软雅黑; font-size: medium; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); display: inline !important; float: none;">new Foo.getName()表示：Foo调用</span><span style="color: rgb(0, 0, 0); font-family: 微软雅黑; font-size: medium; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); display: inline !important; float: none;">getName方法之后将返回值实例化</span></div><div><span style="background-color: rgb(255, 255, 255);">     (</span>new Foo).getName()----Foo的实例去调用getName方法（此处省略括号）；</div><div>     3)出现两个以上new：   </div><div>     除了最近的那个是new构造函数，其他都是new整体（最近的那个new后的函数不带括号也表示new一个整体）</div><div>     new<span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;"> new new Foo().getName();</span>---不带括号new的是整体</div><div>     new (new (new Foo().getName();))---带括号表示new括号里的返回值</div><div>     注意：</div><ul><li>new fn（）----&gt;这里当new出现时，括号就不再具有调用函数的功能，此时new就是调用函数，这个时候括号仅仅是传参；</li><li>看的时候，加上括号是为了看清结构，不要带着括号执行---带不带括号不一样。</li></ul><div><br/></div><div><span style="color: rgb(235, 0, 115);"><span style="font-size: 16px;"><b>上下文模式调用：call（），apply（）</b></span></span></div><div>核心---改变this的指向问题</div><div>语法：形式一致，参数形式不同。</div><div>作用：让函数调用方法在函数调用模式和方法调用模式之间转换，从而改变this的指向。</div><div>1）call形式：</div><div>语法：函数名.call(...);</div><div>    call 调用与 apply 完全相同, 唯一不同是是参数二不需要使用数组 ，直接从第二个参数传进去</div><div>    foo( 123, 567 );</div><div>    foo.apply( null, [ 123, 567 ] );</div><div>    foo.call( null, 123, 567 );----函数处于非严格模式下，this值指定为null或undefined会自动指向全局对象（浏览器中window对象），同时值为原始值 (数字，字符串，布尔值)的this会指向该原始值的自动包装对象。<br/></div><div>2)apply形式：----封装类库框架和构造函数封装方法时使用</div><div>函数名.apply（...）;</div><div>---&gt;他是上下文模式调用的函数</div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">----以下刻在骨头里：</span></div><div>---&gt;这个函数中定义的this已经被改变过了（函数名前有没有'.'已经不重要了）</div><div>---&gt;apply只有由函数调用（只能写成函数名.apply(）);</div><div>---&gt;这样调用以后，函数依旧被执行</div><div>---&gt;这个时候后面的那个括号，至少有一个参数（只有一种情况可以不写）</div><div>---&gt;括号里的第一参数就是该函数中this的指向。</div><div>至此为止，call和apply都是一样的，在第二个参数开始出现不同</div><div> 语法：函数名.apply（obj，数组参数）</div><ul><li>第一个参数表示：‘.’前面的this的指向，是一个对象，传入null不改变this的指向，指代这个函数；</li><li>第二个参数表示：给函数传递的实参，是一个数组，且是一次传入；</li></ul><div>          Foo.apply(stu,<span style="color: rgb(227, 0, 0);"><b>[1,2,3</b></span>]);---&gt;Foo(<span style="color: rgb(227, 0, 0);"><b>m,n,p</b></span>);</div><ul><li>如果给函数传参，第一个参数必须写（占位）；</li></ul><div>          不传参，第一个参数写null；---至少有一个参数---相当于函数调用方式；</div><div>                       第一个参数写一个对象---相当于方法调用方式</div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>foo.apply( o );//提供了一个宿主</div></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">foo.apply( null );//提供了宿主</span></span></span></div></div><div>          </div><ul><li>apply一定是建立在函数可以调用起来的基础上使用,只在当前作用域生效，不会影响后续this的指向</li></ul><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">注意：</span></div><ul><li>不要改变构造函数的this指向---&gt;</li></ul><div>          function Person(){};</div><div>          new Person.call();----&gt;错</div><div>          Person.call();-----&gt;对</div><ul><li>函数体里的this不会指向这个函数，他和调用函数有关系</li><li>apply（）只能用函数来调用，不能用对象调用；</li></ul><div><span style="font-size: 16px;"><span style="color: rgb(235, 0, 115);"><b>bind（）：</b></span></span></div><div>语法：var 变量名=函数名.bind（对象）；</div><div>作用：把某个对象和这个函数相绑定；</div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">与call（）和apply（）的区别：</span></div><ul><li>bind（）括号里只有一个参数，且这个参数是一个对象，该方法就是将这个对象和函数相绑定；</li><li>bind（）调用的时候当前语句中的函数不执行；---只是将该对象和函数相绑定而已</li><li>bind（）有返回值，即它前面的那个函数，调用时相当于---&gt;对象.函数名；</li><li>此时想让函数执行，必须用一个变量接收返回值，用变量名调用---&gt;变量名（）；</li></ul><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">与call（）和apply（）的相同：</span></div><ul><li>都可以改变当前函数中this的指向：把前面函数中this的指向变成后面括号内的对象；</li><li>都需要使用函数调用；</li><li>都不会影响原先的函数，它后面的语句照常使用；</li></ul><div><span style="color: rgb(227, 0, 0);"><span style="font-size: 21px;"><b>3.继承的又一种方法---构造函数方式</b></span></span></div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>function Person ( name, age, gender ) {</div><div>        this.name = name;</div><div>        this.age = age;</div><div>        this.gender = gender;</div><div>    }</div><div><br/></div><div>    function Student ( name, age, gender, course ) {</div><div><br/></div><div>        Person.call( this, name, age, gender );//this指当前构造函数的实例对象</div><div>                                              //让this调用Person构造函数，实现动态赋值</div><div>                                              //这就实现了从构造函数Person的继承</div><div>        this.course = course;</div><div>    }</div><div><br/></div><div>    var p = new Student ( 'jim', 19, 'male', '前端' );</div></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><img src="第六天 函数知识点扩展_files/Image.png" type="image/png" style="height: auto;"/></div><div><span style="font-size: 21px;"><span style="color: rgb(227, 0, 0);"><b>Object.prototype 的成员</b></span></span></div><div>    1) constructor---指向所属的构造函数</div><div>    2) hasOwnProperty 判断该属性是否为自己提供---原型上的属性不考虑</div><div>    3) propertyIsEnumerable 判断属性是否可以枚举 （隐身--是否能被for循环遍历出）</div><div>----在控制台显示是虚的</div><div>    4) isPrototypeOf    判断是否为原型对象 （验证是否是原型）</div><div>    5) toString, toLocaleString, valueOf</div><div><span style="font-size: 21px;"><span style="color: rgb(227, 0, 0);"><b>语法糖：---方便开发的语法结构</b></span></span></div><div>即：getter和setter读写器</div><div>作用：获取和设置数据</div><div style="box-sizing: border-box; padding: 8px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">var o = (function () {</span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">        var num = 123;</span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">        return {</span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">            get_num: function () {</span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">                return num;</span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">            },</span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">            set_num: function ( v ) {</span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">                num = v;</span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">            }</span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">        };</span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">    })();</span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">     // 获得数据</span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">    o.get_num();            =&gt; o.num 形式</span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);"><br/></span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">    // 设置</span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">    o.set_num( 456 );        =&gt; o.num = 456 形式</span></span></span></div><div><br/></div></div><div><br/></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">  改造后：真正的'</span></span></span><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">语法糖</span></span></span> <span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">';</span></span></span></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><b>var o = (function () {</b></div><div><b>        var num = 123;</b></div><div><b>        return {</b></div><div>               //get作为关键字做引导</div><div>            // get 名字 () { 逻辑体 }</div><div>            <b>get num () {</b></div><div><b>                return num;</b></div><div><b>            }</b></div><div><br/></div><div>            // set 名字 ( v ) { 逻辑体 }</div><div>          <b>  set num ( v ) {</b></div><div><b>                num = v;</b></div><div><b>            }</b></div><div>    <b>    };</b></div><div><b>    })();</b></div><div>     //获取数据</div><div>     o.num;//123</div><div>     //设置数据</div><div>     o.num=12;</div></div><div><br/></div><div>读写器就是一种格式，不要深究原理，记住书写格式即可。</div><div><br/></div><div><span style="font-size: 21px;"><b><span style="color: rgb(227, 0, 0);">ES5 中引入的部分数组方法</span></b></span></div><div>    1&gt;<span style="color: rgb(235, 0, 115);"><b>forEach</b></span> -- 遍历</div><div>  <span style="font-size: 15px;"> </span> 数组.forEach(function (item,index){})<span style="font-size: 15px;"><span style="color: rgb(65, 173, 28);"><b>;</b></span></span></div><div>       遍历循环数组，参数中那个函数里面的 item 就是数组中每一项的值；index就是数组的索引。</div><div>      <span style="color: rgb(65, 173, 28);"><b> 他没有返回值。</b></span></div><div>     <span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">----&gt;jQuery中的each方法：</span></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">               $.each(function (index,item){});</span></div><div>    2&gt; map --地图  </div><div>    语法：</div><div>     数组.map（function（item，index）{</div><div>               return item * item;</div><div>     }）;</div><div>     ---核心还是遍历数组，只不过<span style="color: rgb(50, 135, 18);"><b>有返回值</b></span>，返回值是把数组中的每一项都替换掉</div><div>     不会破坏原数组，map返回一个新数组，是通过函数里的算法计算好的数组 </div><div>    3&gt; filter --- 筛选</div><div>     语法：数组.filter(function(item,index){return 条件})</div><div>把原先数组中所有符合我们设定条件的值全部打包放到<span style="color: rgb(65, 173, 28);"><b>新数组</b></span>中返回</div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div> var a = arr.filter( function ( v ) { return v % 2 === 1; });</div></div><div><br/></div><div>    4&gt; some</div><div><b>判断原数组中<span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">至少有一个</span>数据复合要求 就返回 true, 否则返回 false</b></div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>var arr = [ '123', {}, function () {}, '123' ];</div><div>判断数组中至少有一个数字</div><div>var isTrue = arr.some( function ( v ) { return typeof v === 'number'; } );//false</div></div><div><br/></div><div>    5&gt; every</div><div><b>必须满足<span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">所有元素</span>都符合要求才会返回 true</b></div><div><b> </b></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>var arr = [ 1, 2, 3, 4, 5, '6' ];</div><div>var isTrue = arr.every( function ( v ) { return typeof v === 'number'; } );//true</div></div><div><br/></div><div>    6&gt; indexOf    </div><div>         也有返回值，查找原数组中有没有我们传递的参数的这一项，如果有，就返回对应的索引，没有就返回-1，</div><div>     indexOf(a,1)---第一个参数是要查找的元素</div><div>                             第二个参数是设置查找的初始位置，不写默认是0</div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>var arr = [ 1, 2, 3, 4, 5, 4, 5, 6 ];</div><div>         var res = arr.indexOf( 4, 4 );</div><div>         console.log( res );</div></div><div><br/></div><div>    7&gt; lastIndexOf</div><div>     lastIndexOf 和 indexOf一模一样，只不过是倒过来找（也就是从右至左的找），数组的索引不倒过来，还是原先的顺序。</div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>lastIndexOf </div><div>    // var arr = [ 1, 2, 3, 4, 5, 4, 5, 6 ];</div><div>    // var res = arr.lastIndexOf( 4 );</div><div>    // console.log( res );</div></div><div><br/></div><div><img src="第六天 函数知识点扩展_files/Image [1].png" type="image/png" style="height: auto;"/></div></span>
</div></body></html> 