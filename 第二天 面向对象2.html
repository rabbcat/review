<html>
<head>
  <title>第二天 面向对象2</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/303788 (zh-CN, DDL); Windows/6.2.9200 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="581"/>
<h1>第二天 面向对象2</h1>

<div>
<span><div><span style="font-size: 24px;"><b><span style="color: rgb(227, 0, 0);">1.值类型与引用类型的存储特征与赋值</span></b></span></div><div><span style="font-size: 15px;"><i><span style="color: rgb(235, 0, 115);"><b>1.1 存储特征</b></span></i></span></div><div><span style="color: rgb(65, 173, 28);"><span style="font-size: 12px;"><b><font face="微软雅黑">基本数据类型（值类型）：直接存储值--栈</font></b></span></span></div><div><span style="color: rgb(1, 1, 1);">只需要开辟一段内存存储数据即可</span></div><div><b>赋值：</b></div><div><br/></div><div align="left" style="min-height: 153pt;"><div><img src="第二天 面向对象2_files/Image.png" type="image/png" style="height:auto;" width="223"/></div></div><div align="left" style="min-height: 12pt;"><div><span style="color: rgb(50, 135, 18);"><span style="font-size: 12px;"><font face="微软雅黑"><b>复杂数据类型（引用类型）：存储引用--栈中存地址，堆中存内容</b></font></span></span></div><div><span style="color: rgb(1, 1, 1);">对象才是真正的数据, 需要占据单独的内存</span></div><div><b><font color="#010101">赋值：</font></b></div><div><img src="第二天 面向对象2_files/Image [1].png" type="image/png" style="height:auto;" width="253"/></div><div>改变p2的值，p1也改变</div><div><span style="color: rgb(50, 135, 18);"><i><b>js中，允许多个变量指向一个地址，不允许一个变量指向多个地址</b></i></span></div><div><i><b><span style="color: rgb(235, 0, 115);"><span style="font-size: 15px;">1.2 函数参数传递（值类型与引用类型的传参 ）</span></span></b></i></div><div>a.值类型的传参</div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>function foo ( num ) {</div><div>        console.log( 'num = ' + num );//123</div><div>        num++;</div><div>        console.log( 'num = ' + num );//124</div><div>    }</div><div><br/></div><div>    var a = 123;</div><div>    console.log( 'a = ' + a );//123</div><div><br/></div><div>    foo( a ) ;//执行函数，num=a</div><div><br/></div><div>    console.log( 'a = ' + a );123</div></div><div><br/></div><div><br/></div><div>b.引用类型的传参</div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>function foo ( num ) {</div><div>        console.log( 'num = ' + num );123</div><div>        num[ 0 ]++;</div><div>        console.log( 'num = ' + num );124</div><div>    }</div><div><br/></div><div>    var a = [ 123 ];</div><div>    console.log( 'a = ' + a );123</div><div><br/></div><div>    foo( a ) ;//执行函数，num=a</div><div><br/></div><div>    console.log( 'a = ' + a );124</div></div><div><br/></div><div><b><span style="color: rgb(227, 0, 0);"><span style="font-size: 24px;">2.构造函数( 构造器 controctor )的作用</span></span></b></div><div><span style="font-size: 16px;"><span style="color: rgb(235, 0, 115);"><i><b>2.1 js 中对象的动态特性</b></i></span></span></div><div><i><span style="color: rgb(235, 0, 115);"><b>     </b></span></i>对象没有指定属性，利用赋值可以给对象提供该属性<br/></div><div><i><span style="font-size: 16px;"><span style="color: rgb(235, 0, 115);"><b>2.2点语法和关联数组语法</b></span></span></i></div><div>        o.name = 'jim';                // 点语法赋值</div><div>        console.log( o.name );        // 点语法取值</div><div>        o[ 'name' ] = 'tom';        // +关联数组语法赋值</div><div>        console.log( o[ 'name' ] ); // 关联数组语法取值</div><div>        <span style="color: rgb(26, 144, 185);"><b><span style="font-size: 16px;">  特殊用法：</span></b></span></div><div><br/></div><div>                 1.传入数字：arr[1]=10;---这个时候将arr看成一个伪数组</div><div>                 2.传入变量：var age;//undefined;</div><div>                                     obj[age]=10;</div><div>                                     <img src="第二天 面向对象2_files/Image [2].png" type="image/png" style="height: auto;"/></div><div>                 3.也可以：</div><div>                    传入对象：</div><div>                                   var arr=[];</div><div>                                   <img src="第二天 面向对象2_files/Image [3].png" type="image/png" style="height: auto;"/></div><div>                    传入函数：</div><div>                                   var fn=function(){};</div><div>                                   <img src="第二天 面向对象2_files/Image [4].png" type="image/png" style="height: auto;"/></div><div>                     注意：</div><div>                         1. 如果 name 是一个变量, 里面存储的是字符串, 也是可以的</div><div>                              o[ name ] = 'jack';   ---尽量不要这样使用</div><div>                         2.如果非要这样使用，尽量写入一个真实的变量名，且变量名的值必须是基本的数据类型</div><div>                 </div><div><i><span style="color: rgb(235, 0, 115);"><b><span style="font-size: 16px;">2.3工厂函数</span></b></span></i></div><ul><li>    <span style="color: rgb(26, 144, 185);">最原始的创建对象</span></li></ul><div>    </div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>    var p = {};        // 什么都没有的对象</div><div>        // 根据需要添加成员</div><div>        p.name = '张三';</div><div>        p.age = 30;</div><div>        p.gender = '男';</div></div><div><br/></div><div><span style="color: rgb(65, 173, 28);"><b>这样做的缺点：</b></span></div><div><span style="color: rgb(65, 173, 28);"><b>         代码冗余量高，太繁琐(用一次创建一次)</b></span></div><ul><li>     <span style="color: rgb(26, 144, 185);">简化: 提供一个创建 Person 对象的函数-----<span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">工厂函数</span>（</span> <span style="color: rgb(26, 144, 185);">这种类型的函数就是用来创建对象的, 即生产对象. 常常将这类函数称为 '工厂函数'）</span></li></ul><div>      </div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>  function createPerson( name, age, gender ) {</div><div>            var p = {};</div><div>            p.name = name;</div><div>            p.age = age;</div><div>            p.gender = gender;</div><div>            return p;//返回这个对象</div><div>        }</div><div>        var p1 = createPerson( 'jim', 19, '男' );</div><div>        var p2 = createPerson( 'lily', 18, '女' );</div></div><div><br/></div><div><span style="font-size: 16px;"><span style="color: rgb(235, 0, 115);"><i><b>2.4 构造函数</b></i></span></span></div><div><span style="font-size: 15px;"><span style="color: rgb(65, 173, 28);"><b>2.4.1 和工厂函数的区别：</b></span></span></div><div>a.不需要return，自动返回this（也可以写，但是强烈建议不写）</div><div>b.使用new运算符调用构造器</div><div>c.构造器中，this表示当前实例化对象---this.xxx</div><div>d.不需要手动创建一个对象 ---<span style="color: rgb(77, 206, 29);"><span style="color: rgb(65, 173, 28);">var this={};</span></span></div><div><span style="color: rgb(26, 144, 185);"><b>2.4.2 定义</b></span></div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>function createPerson( name, age, gender ) {</div><div>        <span style="color: rgb(77, 206, 29);">  <span style="color: rgb(65, 173, 28);">//脑补一个var this={};</span></span></div><div>           this.name = name;</div><div>            this .age = age;</div><div>            this .gender = gender;</div><div>          <span style="color: rgb(65, 173, 28);">//脑补一个return this</span></div><div>        }</div></div><div><br/></div><div><b><span style="color: rgb(26, 144, 185);">2.4.3 调用</span></b></div><div>     var p = new createPerson( '李磊', 19, '男' ); //实例化一个实例对象p,this指向p</div><div><b><span style="color: rgb(65, 173, 28);">注意：</span></b></div><div>        构造器创建对象的本质: 还是使用对象的动态特性</div><div>        -&gt; 首先执行 new 运算符. 即创建对象. 可以简单看做为 {} 的简写</div><div>            var p = new ...   '相当于'   var p = {}---字面量创建对象</div><div>        -&gt; 调用构造器. 并隐含一个参数, 即刚刚创建的对象.</div><div>          </div><div>        -&gt; 在构造器中使用 this 引用刚刚创建出来的对象. (this指向当前的实例对象)</div><div>                var p1=new createPerson( '李磊', 19, '男' );//this---p1</div><div>                var p2=new createPerson( '李磊', 19, '男' );//this---p2</div><div>        -&gt; 构造器结束是 默认返回 this</div><div>         --&gt;构造函数的实例化过程中，若不传参，可以不写后面的括号（建议写）；</div><div><span style="color: rgb(65, 173, 28);"><b>补充：</b></span></div><div>        -&gt; 构造器的名字, 一般使用 Pascal 命名规则( 首字母大写的 )</div><div>        -&gt; 一般为了与其他面向对象的编程语言( C++, C#, Java )保持一致. 称<span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">构造函数名为类名</span> ---Person--&gt;类名</div><div>          内置类：string,array,function,object,Math,Date,Event</div><div> </div><div><span style="font-size: 24px;"><b><span style="color: rgb(227, 0, 0);">3.异常</span></b></span></div><div><i><span style="color: rgb(235, 0, 115);"><b>3.1概念</b></span></i>--代码在执行过程中出现的错误. 并不是代码的语法错误.</div><div>               ------&gt;一旦出现异常, 其后的代码, 不再执行（uncaught）</div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>&lt;script&gt;</div><div>    // 例如: 将页面中第一个 a 标签的 href 设置为 http://www.itcast.cn</div><div><br/></div><div>    var a = 1 b = 2;</div><div><br/></div><div>    var list = document.getElementsByTagName( 'a' );</div><div>    list[ 0 ].href = 'http://www.itcast.cn';//页面上没有a标签</div><div><br/></div><div>    console.log( 'Hello' );//不执行</div><div>&lt;/script&gt;</div></div><div><br/></div><div><i><span style="color: rgb(235, 0, 115);"><b>3.2 try-catch 语法</b></span></i></div><div>        <span style="color: rgb(65, 173, 28);"><b>1) try-catch 形态</b></span></div><div>            try {</div><div>                代码//一定会被执行，如果出现异常，不中断代码的执行，但是不做真实反映（执行了但是不让错误终止程序）</div><div>            } catch ( e ) {</div><div>                代码 //e是一个标识符，随便写；---e接收的是try中的异常</div><div>                         //try有异常，执行catch的代码，否则不执行</div><div>            }</div><div>           //**表示最终在控制台打印出的结果</div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>  console.log( 1 );**</div><div>    try {</div><div><br/></div><div>        var list = document.getElementsByTagName( 'a' );//没有a标签，异常</div><div>        list[ 0 ].href = 'http://www.itcast.cn';</div><div><br/></div><div>        console.log( 2 );</div><div>    } catch ( e ) {</div><div>        console.log( 'e: ' + e );</div><div>        console.log( 3 );**</div><div>    }</div><div><br/></div><div>    console.log( 4 );**</div></div><div><br/></div><div>    <b><span style="color: rgb(65, 173, 28);">    2) try-catch-finally 形态</span></b></div><div>          </div><div style="margin-left:40px;">  try {</div><div>                代码</div><div>            } catch ( e ) {</div><div>                代码 //e是一个标识符，随便写（一般写e或者err）</div><div>            }</div><div>             finally{</div><div>                 代码//无论是否出现异常, try 语法结束的时候都要执行</div><div>               }</div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>console.log( 1 );**</div><div>    try {</div><div><br/></div><div>        var list = document.getElementsByTagName( 'a' );</div><div>        list[ 0 ].href = 'http://www.itcast.cn';</div><div><br/></div><div>        console.log( 2 );</div><div>    } catch ( e ) {</div><div>        console.log( 'e: ' + e );**</div><div>        console.log( 3 );**</div><div>    } finally {</div><div>        console.log( 5 ); **// 无论是否出现异常, try 语法结束的时候都要执行 finally 中的代码</div><div>    }</div><div><br/></div><div>    console.log( 4 );**</div><div><br/></div></div><div><span style="color: rgb(235, 0, 115);"><i><b>3.3 抛出异常</b></i></span>---框架中常用，不使用系统提供的异常抛出方法，然后使用try-catch 语法处理异常</div><div>a.自定义抛出异常</div><div>        一般可以封装函数完成特定的功能. 例如 tag 函数</div><div>       </div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>function tag ( tagName ) {</div><div>            if ( tagName 不是字符串 ) 抛出异常.</div><div>            return document.getElementsByTagName ( tagName );</div><div>        }</div></div><div><br/></div><div> b. 抛出异常的语法</div><div>        throw 对象</div><div><br/></div><div><span style="font-size: 21px;"><b><span style="color: rgb(227, 0, 0);">只要页面上出现的效果，不管多少次，都是构造函数模式的</span></b></span></div><div><img src="第二天 面向对象2_files/Image [5].png" type="image/png" style="height: auto;"/></div><div><span style="font-size: 24px;"><span style="color: rgb(227, 0, 0);"><b> 4.原型</b></span></span></div><div><i><b><span style="color: rgb(235, 0, 115);">  <span style="font-size: 16px;"> 4.1  为什么需要原型 </span></span></b></i></div><ul><li>   每使用构造函数创建一次，就创建一个对象，同时生成里面的方法，这些对象内的方法是彼此重复的（内容完全相同，但是却又不同的方法）；</li><li>这些彼此重复的方法会无故占用内存空间---&gt;原型可以解决这个问题</li></ul><div>      --------&gt;&gt;解决重复方法占用内存的方法：（提取公用方法）</div><div>                        <b><span style="color: rgb(50, 135, 18);">思路一：将方法函数写在构造函数之外，将此方法赋给构造函数的方法；                                             </span></b></div><div><b><span style="color: rgb(50, 135, 18);">                        <span style="color: rgb(26, 144, 185);"><i>-----缺点：一个对象可能有 n 多方法. 如果将所有的东西 都放到外面, 与其他库</i></span></span></b> <span style="color: rgb(26, 144, 185);"><i><b>冲突的几率就会变大. 所以不宜采取该方法.</b></i></span></div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>&lt;script&gt;</div><div>    function hi(){</div><div>        console.log( '你好, 我是 ' + this.name );</div><div>    }</div><div>    function Person ( name ) {</div><div>        this.name = name;</div><div>        // this.sayHello = tools.sayHello;</div><div>        this.sayHello=hi;</div><div>    }</div><div>    var p1 = new Person( '李雷' );</div><div>    var p2 = new Person( '韩梅梅' );</div><div>    p1.sayHello();</div><div>    p2.sayHello();</div><div>    // 验证</div><div>    console.log( p1.sayHello == p2.sayHello );</div><div>&lt;/script&gt;</div></div><div><br/></div><div>                      <b><span style="color: rgb(50, 135, 18);">  思路二：定义一个对象，将此的方法绑定在这个对象之上；</span></b></div><div><b><span style="color: rgb(50, 135, 18);">                   </span></b></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div> &lt;script&gt;</div><div>    var tools = {</div><div>        sayHello: function () {</div><div>            console.log( '你好, 我是 ' + this.name );</div><div>        }, walk: function () {},</div><div>        sleep: function () {},</div><div>        eat: function () {}</div><div>        // ...</div><div>    };</div><div><br/></div><div>    function Person ( name ) {</div><div>        this.name = name;</div><div>        this.sayHello = tools.sayHello;</div><div>    }</div><div><br/></div><div>    var p1 = new Person( '李雷' );</div><div>    var p2 = new Person( '韩梅梅' );</div><div>    p1.sayHello();</div><div>    p2.sayHello();</div><div>    // 验证</div><div>    console.log( p1.sayHello == p2.sayHello );</div><div>&lt;/script&gt;</div></div><div><br/></div><div>                      <span style="color: rgb(50, 135, 18);"><b>  思路三：使用构造函数的原型属性（prototype）</b></span></div><div><span style="color: rgb(50, 135, 18);"><b>                           <i><span style="color: rgb(26, 144, 185);">                                                                ---使用js原生的方法解决这个问题更便捷</span></i></b></span></div><div><span style="font-size: 16px;"><i><span style="color: rgb(235, 0, 115);"><b>4.2 什么是原型</b></span></i></span></div><div><i><b><span style="font-size: 16px;"><span style="color: rgb(235, 0, 115);"><br/></span></span></b></i></div><div><img src="第二天 面向对象2_files/Image [6].png" type="image/png" style="height: auto;"/></div><div><i><b><span style="font-size: 16px;"><span style="color: rgb(235, 0, 115);"><span style="font-size: 15px;"><span style="color: rgb(50, 135, 18);">     4.2.1定义</span></span></span></span></b></i></div><div><span style="font-size: 15px;"><span style="color: rgb(50, 135, 18);"><b><i>   </i></b></span></span>    每一个函数都有 一个属性 prototype ，该属性指向一对象. 每一个函数的该对象都是存在，这个对象就是原型 </div><div>      (重点) 每一个由该函数作为构造器创建的对象, 都会默认连接到该对象上.</div><div>       如果访问对象的方法, 而对象中没有定义, 就会在这个 构造函数.prototype 表示的对象中去找.(prototype中存储的是这个对象的地址)</div><div><i><b><span style="font-size: 15px;"><span style="color: rgb(50, 135, 18);">     1.原型属性：<br/></span></span></b></i></div><div><i><b><span style="font-size: 15px;"><span style="color: rgb(50, 135, 18);">     </span></span></b></i>针对构造函数而言, 原型就是 构造函数的 <span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">prototype 属性</span>, 常常将其称为原型属性（<span style="color: rgb(26, 144, 185);">这个属性不是我们一般意义上的'属性'，只是叫这个名字</span>）；</div><div>  <span style="color: rgb(50, 135, 18);">  <span style="font-size: 15px;"><i><b> 2.原型对象：</b></i></span></span></div><div>     针对实例对象而言, 原型就是 实例对象的<span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">原型对象。</span></div><div>                                  <span style="font-size: 15px;"><span style="color: rgb(26, 144, 185);"><b> ---原型是构造函数本身的<span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">原型属性</span>，是实例对象的<span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">原型对象</span></b></span></span></div><div> 注意：</div><ul><li>函数存在，这个对象就存在      </li><li>Person.__proto__.name也可以写做Person.name（如果当前的实例对象中没有这个属性，默认自动去原型上找）</li><li>访问 ：    </li></ul><div>                使用构造函数, 就使用 prototype 属性访问原型；</div><div>                使用实例对象, 就使用 非标准的 __proto__ 属性访问原型；</div><div>            </div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>   function Person(){}</div><div>               var p=new Person{};</div><div>               Person.prototype.name;</div><div>               p.__proto__.name;</div><div><br/></div></div><ul><li>__proto__可以修改所属类的原型，也可以修改他祖先的原型，IE6，7，8不支持__proto__，且太强大，一般不使用它，而使用prototype通过构造函数（所属类）修改所属类的原型属性</li><li>如果不写__proto__就从自己的实例出发，然后一级级向上查找；如果写__proto__就从实例的原型对象出发，一级级查找</li></ul><div style="box-sizing: border-box; padding: 8px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">&lt;script&gt;</span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">    function Person(){</span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">        this.name=&quot;李四&quot;;</span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">    }</span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">    Person.prototype.name=&quot;张三&quot;;</span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">    var p=new Person();</span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">    console.log(p.name);//李四</span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">    p.__proto__.name=&quot;猪八戒&quot;;//直接修改所属类的原型</span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">//    Person.prototype.name=&quot;wang&quot;;</span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">//    p.name=&quot;王二&quot;;</span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">    console.log(p.name);//王二</span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">    console.log(p.__proto__.name);//张三</span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">    var p2=new Person();</span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">    console.log(p2.name);//李四</span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">    console.log(p2.__proto__.name);//张三</span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">&lt;/script&gt;</span></span></span></div></div><div><br/></div><div><span style="color: rgb(50, 135, 18);"><span style="font-size: 15px;"><i><b>     4.2.2 使用方法</b></i></span></span></div><div><i><b><span style="font-size: 15px;"><span style="color: rgb(50, 135, 18);"><br/></span></span></b></i></div><div>    <b><span style="color: rgb(26, 144, 185);"> 方法一：直接给原型对象添加成员：</span></b></div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>&lt;script&gt;</div><div>    // 例如创建一个 Person 的构造函数, 让人有名字, 可以说话</div><div>    function Person ( name ) {</div><div>        this.name = name;</div><div>    }</div><div>    Person.prototype.sayHello = function () {</div><div>        console.log( '你好, 我是 ' + this.name );</div><div>    };</div><div>    Person.prototype.walk = function () {</div><div>        console.log( this.name + ' 走了' );</div><div>    };</div><div>    var p1 = new Person( '李雷' );</div><div>    var p2 = new Person( '韩梅梅' );</div><div><br/></div><div>    p1.sayHello();</div><div>    p2.sayHello();</div><div>    // 验证</div><div>    console.log( p1.sayHello == p2.sayHello );</div><div>&lt;/script&gt;</div></div><div><span style="color: rgb(26, 144, 185);"><b>    </b></span></div><div><span style="color: rgb(26, 144, 185);"><b>     方法二：直接替换原型对象 </b></span></div><div><b><span style="color: rgb(26, 144, 185);"><br/></span></b></div><div><span style="color: rgb(26, 144, 185);"><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">      原型属性自带一个DNA，就是这个constructor,指向对应的构造函数（当前所属类）</span></span></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;"><font color="#1A90B9">      每个函数的prototype都可以改变成指向别的对象</font></span></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;"><span style="color: rgb(26, 144, 185);">      我们自己派生出的对象没有 constructor 属性, 需要手动添加 </span></span></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;"><span style="color: rgb(26, 144, 185);"><br/></span></span></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>    &lt;script&gt;</div><div>    // 首先需要构造函数, 原则就是将方法放在 原型中</div><div>    function Person ( name, age, gender ) {</div><div>        this.name = name;</div><div>        this.age = age;</div><div>        this.gender = gender;</div><div>    }</div><div>    // 让 Person.prototype 指向另一个对象. 直接赋值</div><div>    Person.prototype = {</div><div><br/></div><div>        constructor: Person,</div><div><br/></div><div>        sayHello: function () {</div><div>            console.log( '第二种做法: 你好, 我是 ' + this.name );</div><div>        }, eat: function () {</div><div>            console.log( '第二种做法: ' + this.name + ' 在吃饭' );</div><div>        }, run: function () {</div><div>            console.log( '第二种做法: ' + this.name + ' 在跑步. 已经跑了 ' + this.age + ' 年' );</div><div>        }</div><div>    };</div><div><br/></div><div>    var p1 = new Person( 'lilei', 19, '男' );</div><div>    var p2 = new Person( 'hanmeimei', 18, '女' );</div><div><br/></div><div>    //</div><div>    p1.sayHello();</div><div>    p1.eat();</div><div>    p1.run();</div><div><br/></div><div>    console.log( '--------------------------' );</div><div>    p2.sayHello();</div><div>    p2.eat();</div><div>    p2.run();</div><div><br/></div><div>&lt;/script&gt;</div></div><div><br/></div><div><span style="color: rgb(227, 0, 0);"><b><span style="font-size: 21px;">总结：</span></b></span></div><div>           <span style="color: rgb(188, 0, 88);"><b><span style="font-size: 19px;">a.</span><span style="font-size: 16px;">每一个函数都天生自带的一个属性，叫做prototype,该属性指向一个对象（函数名.prototype），每一个函数的的该对象都是存在的。</span></b></span></div><div><span style="color: rgb(188, 0, 88);"><span style="font-size: 16px;"><b>         b.每一个实例都天生自带一个属性，叫__prototype__,他指向所属类的原型</b></span></span></div><div><span style="color: rgb(188, 0, 88);"><span style="font-size: 16px;"><b>         c.原生的prototype上天生带一个属性，叫做constructor，他指向当前所属的类，我们自己派生出的对象没有，要手动添加，让其指向所属的类（一般默认指向当前类，当然也可以指向其他类，只是这样做容易出错，不推荐使用）</b></span></span></div><div><b><span style="font-size: 16px;"><span style="color: rgb(188, 0, 88);">     ---例如：<img src="第二天 面向对象2_files/Image [7].png" type="image/png" style="height: auto;"/></span></span></b></div><div><i><b><span style="font-size: 15px;"><span style="color: rgb(50, 135, 18);"><br/></span></span></b></i></div><div><br/></div><div><b><i><span style="color: rgb(235, 0, 115);"><span style="font-size: 16px;">4.3 原型链查找机制（</span>原型链查找机制是__proto__找到的地址 <span style="font-size: 16px;">）*******</span></span></i></b></div><div><span style="color: rgb(65, 173, 28);"><span style="font-size: 15px;"><b>4.3.1 属性访问原则***</b></span></span></div><div><span style="font-size: 16px;"><span style="color: rgb(235, 0, 115);"><b><i>  </i></b></span></span> 1) 对象在调用方法或访问属性的时候, 首先在当前实例对象中查询. 如果有该成员使用并停止查找.</div><div>    2) 如果没有该成员就在其原型对象中查找. 如果有该成员即使用, 并停止查找.</div><div>    3) 如果还没有就到 该对象的 原型对象 的 原型对象中查找.</div><div>    ...</div><div>    4) 最后会查到 Object.prototype 上. 如果还没有即 返回 undefined.（起初定义了这个变量，一直找不到就定义为window上的全局变量）</div><div><br/></div><div><span style="font-size: 15px;"><span style="color: rgb(65, 173, 28);"><b>4.3.2 属性赋值原则：（不遵循原型链查找机制规则）</b></span></span></div><div>     在自己的对象空间中查找，有没有该属性名，没有就给自己添加，有就修改，<span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">不会按照原型链查找机制去往上找</span> ；</div><div><span style="font-size: 15px;"><span style="color: rgb(65, 173, 28);"><b><i>---&gt;判断系统是否支持__proto__</i></b></span></span></div><div>     if({}.__proto__){</div><div>          console.log('支持')；</div><div>     }</div><div>     else{</div><div>          console.log('不支持')；</div><div>     }</div><div><img src="第二天 面向对象2_files/Image [8].png" type="image/png" style="height: auto;"/></div><div><br/></div><div><br/></div><div><br/></div><div><img src="第二天 面向对象2_files/Image [9].png" type="image/png" style="height: auto;"/></div><div><br/></div><div><br/></div><div><br/></div><div><span style="font-size: 16px;"><i><b><span style="color: rgb(235, 0, 115);">4.4 原型的继承性</span></b></i></span></div><div><i><span style="font-size: 15px;"><b><span style="color: rgb(50, 135, 18);">     4.4.1 什么是继承</span></b></span></i></div><div><span style="font-size: 15px;"><span style="color: rgb(50, 135, 18);"><i><b>         </b></i></span></span>自己没有, 别人有, 拿过来自己用, 就好像自己的一样.</div><div>     <span style="color: rgb(50, 135, 18);"><i><b><span style="font-size: 15px;">4.4.2 为什么要继承？</span></b></i></span></div><div>         同一方法提取出来实现复用，节省代码量。</div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="font-size: 12px;">function Person () {</span></div><div><span style="font-size: 12px;">    this.name = '黄帝';</span></div><div><span style="font-size: 12px;">    this.age = 0;</span></div><div><span style="font-size: 12px;">    this.gender = '男';</span></div><div><span style="font-size: 12px;">}</span></div><div><span style="font-size: 12px;">//Person.prototype.sayHello= function () {</span></div><div><span style="font-size: 12px;">//    console.log(&quot;跑&quot;);</span></div><div><span style="font-size: 12px;">//}</span></div><div><span style="font-size: 12px;">function Student() {</span></div><div><span style="font-size: 12px;">    this.name='haha';</span></div><div><span style="font-size: 12px;">    this.age=10;</span></div><div><span style="font-size: 12px;">    this.gender='女';</span></div><div><span style="font-size: 12px;">}</span></div><div><span style="font-size: 12px;">//Student.prototype.sayHello= function () {</span></div><div><span style="font-size: 12px;">//    console.log(&quot;走&quot;);</span></div><div><span style="font-size: 12px;">//}</span></div><div><span style="font-size: 12px;">//方法重复，考虑提取出来实现公用</span></div><div><span style="font-size: 12px;">    var o = {</span></div><div><span style="font-size: 12px;">        sayHello: function () {</span></div><div><span style="font-size: 12px;">            console.log(1);</span></div><div><span style="font-size: 12px;">        }</span></div><div><span style="font-size: 12px;">    }</span></div><div><span style="font-size: 12px;">Person.prototype=o;//继承o</span></div><div><span style="font-size: 12px;">Student.prototype=o;</span></div><div><span style="font-size: 12px;">var p = new  Person();</span></div><div><span style="font-size: 12px;">var s = new Student();</span></div><div><span style="font-size: 12px;">p.sayHello();</span></div><div><span style="font-size: 12px;">s.sayHello();</span></div><div><span style="font-size: 12px;">//实现方法的公用，这就是继承的原因</span></div><div><span style="color: rgb(65, 173, 28);"><b>为什么不把所有的方法放在o里面----&gt;路走的太远，消耗内存</b></span></div></div><div>     </div><div><b><i><span style="font-size: 15px;"><span style="color: rgb(65, 173, 28);">4.4.3  关于构造函数的一些相关的名词的解释</span></span></i></b></div><div><i><b><span style="font-size: 15px;"><span style="color: rgb(65, 173, 28);">          </span></span></b></i></div><table style="-evernote-table:true;border-collapse:collapse;table-layout:fixed;margin-left:0px;width:100%;"><tbody><tr><td style="border-style:solid;border-width:1px;border-color:rgb(211,211,211);padding:10px;margin:0px;width:34.56%;"><div><i><b><span style="font-size: 15px;"><span style="color: rgb(65, 173, 28);">  成员名    </span></span></b></i></div></td><td style="border-style:solid;border-width:1px;border-color:rgb(211,211,211);padding:10px;margin:0px;width:33.44%;"><div><i><b><span style="font-size: 15px;"><span style="color: rgb(65, 173, 28);">概述                                                    </span></span></b></i></div></td><td style="border-style:solid;border-width:1px;border-color:rgb(211,211,211);padding:10px;margin:0px;width:31.840000000000003%;"><div><i><b><span style="font-size: 15px;"><span style="color: rgb(65, 173, 28);">具体意义</span></span></b></i></div></td></tr><tr><td style="border-style:solid;border-width:1px;border-color:rgb(211,211,211);padding:10px;margin:0px;width:33.30815709969788%;"><div><span style="font-size: 15px;"><span style="color: rgb(65, 173, 28);"><b><i> </i></b></span></span> 类 （class）</div></td><td style="border-style:solid;border-width:1px;border-color:rgb(211,211,211);padding:10px;margin:0px;width:33.30815709969788%;"><div>继承的模板</div></td><td style="border-style:solid;border-width:1px;border-color:rgb(211,211,211);padding:10px;margin:0px;width:33.30815709969788%;"><div>构造函数, 类名就是构造函数名</div></td></tr><tr><td style="border-style:solid;border-width:1px;border-color:rgb(211,211,211);padding:10px;margin:0px;width:33.33%;"><div>子类 subclass</div></td><td style="border-style:solid;border-width:1px;border-color:rgb(211,211,211);padding:10px;margin:0px;width:33.33%;"><div>派生的模板</div></td><td style="border-style:solid;border-width:1px;border-color:rgb(211,211,211);padding:10px;margin:0px;width:33.33%;"><div>原型设置为指定对象的构造函数（所继承的那个对象的类）</div></td></tr><tr><td style="border-style:solid;border-width:1px;border-color:rgb(211,211,211);padding:10px;margin:0px;width:33.33%;"><div>实例 instance</div></td><td style="border-style:solid;border-width:1px;border-color:rgb(211,211,211);padding:10px;margin:0px;width:33.33%;"><div>某个类的对象</div></td><td style="border-style:solid;border-width:1px;border-color:rgb(211,211,211);padding:10px;margin:0px;width:33.33%;"><div>使用某个类通过new创建的对象</div></td></tr><tr><td style="border-style:solid;border-width:1px;border-color:rgb(211,211,211);padding:10px;margin:0px;width:33.33%;"><div>实例成员</div></td><td style="border-style:solid;border-width:1px;border-color:rgb(211,211,211);padding:10px;margin:0px;width:33.33%;"><div>实例方法, 实例属性</div></td><td style="border-style:solid;border-width:1px;border-color:rgb(211,211,211);padding:10px;margin:0px;width:33.33%;"><div>通过实例化后实例对象获得的方法和属性</div></td></tr><tr><td style="border-style:solid;border-width:1px;border-color:rgb(211,211,211);padding:10px;margin:0px;width:33.33%;"><div>静态成员</div><div><br/></div></td><td style="border-style:solid;border-width:1px;border-color:rgb(211,211,211);padding:10px;margin:0px;width:33.33%;"><div>静态方法， 静态属性</div></td><td style="border-style:solid;border-width:1px;border-color:rgb(211,211,211);padding:10px;margin:0px;width:33.33%;"><div>静态方法：直接绑定在函数上的方法</div><div>静态属性：直接绑定在函数上的属性</div></td></tr></tbody></table><div><br/></div><div><br/></div><div><b><i><span style="font-size: 15px;"><span style="font-size: 16px;"><span style="color: rgb(235, 0, 115);"><span style="color: rgb(50, 135, 18);">     4.4.4 继承详述</span></span></span><span style="color: rgb(65, 173, 28);">                                      </span></span></i></b></div><div>         </div><ul><li>任何一个实例, 都是继承自其原型对象的. 即原型式继承.</li><li>在 js 中, 方法定义在原型对象中, 而属性定义在实例对象中 调用方法的时候, 实例对象本身是没有该成员的, 但是依旧可以调用该方法, 好像这个方法就是该实例对象的一样. 因此, 我们称该</li></ul><div><span style="font-size: 16px;"><i><span style="color: rgb(65, 173, 28);"><b>                   实例对象继承自原型对象----原型继承</b></span></i></span></div><div><i><b><span style="font-size: 16px;"><span style="color: rgb(65, 173, 28);">    <span style="color: rgb(26, 173, 224);">a.原型式继承：</span><br/></span></span></b></i></div><div><span style="font-size: 16px;"><span style="color: rgb(65, 173, 28);"><i><b>      </b></i></span></span> 写一个构造函数, 如果需要将其实例继承自某个特定的对象 o. 那么</div><div>        只需要设置该构造函数的 prototype 属性为 o 即可</div><div><br/></div><div>      </div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>       function Person {}</div><div><br/></div><div>        var o = {</div><div>          sayHello: function () {</div><div>              console.log(1);</div><div>               }</div><div>        }</div><div>        Person.prototype = o;    // 继承</div><div>        var p1=new Person();</div><div>        p1.sayHello();</div></div><div><br/></div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>    function Person () {</div><div>        this.name = '黄帝';</div><div>        this.age = 0;</div><div>        this.gender = '男';</div><div>    }</div><div><br/></div><div>    // 不叫子类, 只是一个 Student 类</div><div>    function Student() {</div><div>    }</div><div><br/></div><div>    // 继承派生 成为子类</div><div>    Student.prototype = new Person();</div><div><br/></div><div>    // 即完成派生</div><div>    var s = new Student();//s继承自Person的实例</div><div>    s.name // OK</div></div><div><b><span style="font-size: 16px;"><span style="color: rgb(250, 122, 0);"><br/></span></span></b></div><div><span style="font-size: 16px;"><span style="color: rgb(250, 122, 0);"><b>当第二个构造函数出现以后，且第二个构造函数的prototype指向了第一个构造函数的实例的时候，那么我们就说第二个构造函数是第一个构造函数的子类。</b></span></span></div><div><b><span style="font-size: 16px;"><span style="color: rgb(250, 122, 0);"> </span></span></b></div><div><span style="color: rgb(65, 173, 28);"><span style="font-size: 15px;"><i><b>a-1.所有的对象都可以看做是Object构造函数的实例（Object类实例 ），除非他是别的构造函数创造的实例;</b></i></span></span></div><div>----Object.new---&gt;所有的对象，然后我们可以通过这个任意对象.__proto__访问Object的原型对象</div><ul><li>因为Person.prototype也是一个对象，所以也可以看成是Object的实例化对象；</li><li>Person.prototype.__proto__==Object.prototype</li><li>每一个函数的原型都是一个对象，那么每一个函数的原型的__proto__都默认指向Object.prototype；</li><li>Object构造函数叫做‘基类'；</li><li>Object.prototype指向为null（因为即使Object.prototype也是一个对象，但是它并不能是自身的实例）。</li></ul><div><span style="color: rgb(26, 173, 224);"><i><b><span style="font-size: 16px;">b.混入（js没有内置该方法，需要手动实现，jQuery中则提供了该方法）</span></b></i></span></div><div>  语法：1</div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>    var o1 = { name: '张三' };</div><div>    var o2 = { age: 19 };</div><div><br/></div><div>    o2.name = o1.name;</div></div><div><br/></div><ul><li>    利用这个简单的赋值, 就可以将一个对象中的成员加到另一个对象中;</li><li>    混入使得 o2 具有了 age 和 o1 中的 name. 即:将 o1 混入到 o2 中;</li><li>    <span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">混入也是一种继承的方式;</span></li></ul><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;"><br/></span></div><div><span style="font-size: 15px;"><span style="color: rgb(65, 173, 28);"><b>    具体实现：</b></span></span></div><div>    </div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div> // 考虑需要执行, 写函数即可---<span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">这只是一个函数</span></div><div>    // 由于将 一个 对象混入到 另一个对象. 所以有两个参数</div><div>    function __mix__ ( obj, obj1 ) {</div><div>        // 如何获得 obj1 中的所有成员?</div><div>        for ( var  k in obj1 ) {</div><div>            obj[ k ] = obj1[ k ];</div><div>        }</div><div>    }</div><div>        var o1 = { name: '张三', age: 19 };</div><div>        var o2 = { gender: '男' };</div><div>        __mix__( o2, o1 ); //将o1混入到o2中</div><div><br/></div></div><div><br/></div><ul><li>核心原理：for _in循环，把这个循环放到一个函数里，是为了每次想混入继承的时候，直接使用方法即可；</li><li>不破坏obj原有的元素，是将obj1中的东西加入到obj中，保留obj原有的元素；</li><li>__mix__这样命名是因为这个方法是一个非标操作，便于识别；__mix__私有，extend一般是公开的；</li><li>每个实例都是一个对象，可在外边随便定义一个对象，里面写上方法和属性</li></ul><div>     <span style="font-size: 15px;"><span style="color: rgb(26, 144, 185);"><b>b-1.混入的扩展</b></span></span></div><div>     希望混入是一个<span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">方法</span>, 将别人的东西加到我身上</div><div>     __mix__( 原对象, 新对象 ) ----原来的</div><div>   <b>  原对象.__mix__( 新对象 ) -----期望实现的结果</b></div><div><i><span style="color: rgb(65, 173, 28);"><b>b-1-1.单个实参情况  </b></span></i>  </div><div><br/></div><div>sectionA:  函数实现</div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>function __mix__(obj1,obj2){</div><div>    for(var k in obj1){</div><div>        obj2[k]=obj1[k];</div><div>    }</div><div>}</div><div>__mix__(o1,o2);</div></div><div><br/></div><div><br/></div><div>sectionB：方法实现</div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>var o = {</div><div>         __mix__: function ( obj ) {</div><div>        // 将 obj 中的成员 加到 当前对象 this 上</div><div>             for ( var k in obj ) {</div><div>                 this[ k ] = obj[ k ];</div><div>             }</div><div>         }</div><div>     };</div><div>o.__mix__(o2);</div></div><div><br/></div><div> --&gt;__mix__---&gt;extend</div><div>    <span style="font-size: 15px;"><span style="color: rgb(65, 173, 28);"><b>   <span style="color: rgb(26, 144, 185);">一般现在很多开发库, 都使用 extend 名字 ，extend只是开发者默认的一个名字而已----实质是相同的</span></b></span></span></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>var o = {</div><div>     extend: function ( obj ) {</div><div>         // 将 obj 中的成员 加到 当前对象 this 上</div><div>         for ( var k in obj ) {</div><div>             this[ k ] = obj[ k ];</div><div>         }</div><div>     }</div><div> };</div><div>o.extend(o2);</div></div><div><span style="color: rgb(65, 173, 28);"><i><b>b-1-2.多个实参情况</b></i></span></div><div><i><b><span style="color: rgb(65, 173, 28);"><br/></span></b></i></div><div>sectionA:函数实现</div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>function all(){</div><div>    var sum=0;</div><div>    for(var i=0;i&lt;arguments.length;i++){</div><div>        sum+=arguments[i];</div><div>    }</div><div>    return sum;</div><div>}</div><div>console.log(all(1, 3, 5, 7, 9));</div><div>function all(obj1){</div><div>    for(var i=0;i&lt;arguments.length;i++){</div><div>        for(var k in arguments[i]){</div><div>            obj1[k]=arguments[i][k];</div><div>        }</div><div>    }</div><div>}</div><div>var o={&quot;name&quot;:&quot;张三&quot;,&quot;gender&quot;:&quot;男&quot;};</div><div>all(o);</div></div><div><br/></div><div>sectionB:方法实现</div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>var o = {</div><div>        name:&quot;小明&quot;,</div><div>        extend: function (obj) {</div><div>           for(var i=0;i&lt;arguments.length;i++){</div><div>               for(var k in arguments[i]){</div><div>                   this[k]=arguments[i][k];</div><div>               }</div><div>           }</div><div>        }</div><div>    };</div><div><br/></div><div>o.extend(</div><div>        {'hair':'long'},</div><div>        {'gender':'女','birthday':11.2},</div><div>        {age:19,</div><div>            sayHi: function () {</div><div>            console.log(&quot;hi&quot;);</div><div>        }</div><div>        }</div><div>);</div></div><div><br/></div><div><br/></div><div><span style="font-size: 16px;"><span style="color: rgb(26, 144, 185);"><b>    <i> c.混合式继承</i></b></span></span></div><div>         混合就是将<span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">多个对象的各个功能</span>混合到一起, 加到构造函数的原型对象上，那么该构造函数创建的实例 就继承自多个对象了.（不用逐一继承，一步到位）</div><div><span style="color: rgb(235, 0, 115);"><b>具体化：</b></span></div><ol><li>第一步，当前构造函数的原型，混入多个对象的属性和方法；（原型混入）</li><li>第二步，当前构造函数的实例继承自当前构造函数的原型 ；（实例.__proto__---&gt;构造函数的原型）</li></ol><ul><li>          如果是原型混入，那么当前构造函数的每一个实例对象都可以使用这些方法；</li><li>          如果混入到当前构造函数的某一实例的时候，那么只有这个实例可以使用。（只有当前这个对象有这个方法或属性）。--当且仅当      </li></ul><div>代码示例：</div><div> </div><div><span style="color: rgb(248, 248, 242);"><br/></span></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>function Person(){</div><div><br/></div><div>    }</div><div>var p = new Person();</div><div>Person.prototype.extend= function (obj) {</div><div>    for(var k in obj){</div><div>            this[k]=obj[k];</div><div>        }</div><div>}</div><div>Person.prototype.extend(</div><div>        {</div><div>            sayHello: function () {</div><div>                console.log( '你好, 我是新加的' )</div><div>            },</div><div>            walk: function () {},</div><div>            eat: function () {}</div><div>        }</div><div>)</div><div>p.sayHello();//p继承自拎一个新的对象</div></div><div><span style="color: rgb(248, 248, 242);"><br/></span></div><div> </div><div><span style="font-size: 21px;"><span style="color: rgb(227, 0, 0);"><b>5.Object.create()方法：（系统内置）---继承的经典结构</b></span></span></div><div>语法：新对象=Object.create（原对象）；</div><div>作用：创建一个新对象，可以通过.__proto__访问该对象</div><div>示例：</div><div style="box-sizing: border-box; padding: 8px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><font color="#333333" face="Monaco, Menlo, Consolas, Courier New, monospace" size="2">方法原理模拟：</font></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">Object.create= function (o) {</span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">    function F(){};</span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">    F.prototype=o;</span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">    return new F();</span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">}</span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">var obj=Object.create({name:&quot;张三&quot;});</span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">console.log(obj);</span></span></span></div></div><ul><li>实质上该方法是使这个构造函数的 prototype指向传入的这个对象---原型继承</li><li>通过该方法得到的是该构造函数的实例对象</li><li>这个得到的实例对象的__proto__指向传入的这个对象</li><li>Object作为基类，就是用来创建对象的，所以把create方法作为它的静态方法，Object只负责调用该方法</li><li>只是提供了系统的一个继承的快捷方法，无需new即可得到一个构造函数的实例对象</li><li>create方法只允许Object使用，他是Object的内置静态方法，用来创建对象</li></ul><div>    <span style="font-size: 16px;"><i><span style="color: rgb(50, 135, 18);"> <span style="color: rgb(65, 173, 28);"><b>兼容性写法：---封装函数思想</b></span></span></i></span></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>function createWithObject ( obj ) {</div><div>        if ( Object.create ) {</div><div>            return Object.create( obj );</div><div>        } else {</div><div>            function F() {}</div><div>            F.prototype = obj;</div><div>            return new F();</div><div>        }</div><div>    }</div><div>var obj1=createWithObject({name:&quot;张三&quot;});</div></div><div><span style="font-size: 21px;"><span style="color: rgb(227, 0, 0);"><b>6.原型链机制</b></span></span></div><div><i><b><span style="font-size: 16px;"><span style="color: rgb(26, 144, 185);">什么是原型链：</span></span></b></i></div><div>由__proto__指向某构造函数的原型属性的链式结构。</div><div><span style="font-size: 16px;"><i><span style="color: rgb(26, 144, 185);"><b>原型链结构：</b></span></i></span></div><div>   function Person(){};</div><div>   var p=new Person();</div><div> <span style="color: rgb(65, 173, 28);">  p --&gt; Person.prototype( p.__proto__ ) --&gt; Object.prototype --&gt; null</span></div><div><span style="color: rgb(65, 173, 28);"><br/></span></div><div><i><span style="font-size: 16px;"><span style="color: rgb(26, 144, 185);"><b>系统内置原型链：</b></span></span></i></div><div>     [] --&gt; Array.prototype --&gt; Object.prototype --&gt; null</div><div>     /./ --&gt; RegExp.prototype --&gt; Object.prototype --&gt; null</div><div>注意：原型链不宜过多，最多3~4节，太多会浪费浏览器内存，要实现更多的方法可也通过混入实现（省去多次继承）</div><div><span style="font-size: 21px;"><b><span style="color: rgb(227, 0, 0);">7.对象的字面量</span></b></span></div><div>JS中的对象一般都有字面量：</div><div>    数组: []</div><div>    正则表达式对象: /./</div><div>    函数: function () {}</div><div>    ...</div><div><br/></div><div>    对象: {}</div><div>    {} --&gt; Object.prototype --&gt; null</div><div>    <span style="font-size: 16px;"><span style="color: rgb(65, 173, 28);">注意:</span></span></div><div>     {} 与 new Object() 含义相同 <img src="第二天 面向对象2_files/Image [10].png" type="image/png" style="height: auto;"/></div><div><br/></div><div><br/></div><div><img src="第二天 面向对象2_files/Image [11].png" type="image/png" style="height: auto;"/></div><div><img src="第二天 面向对象2_files/Image [12].png" type="image/png" style="height: auto;"/></div></div></span>
</div></body></html> 