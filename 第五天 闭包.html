<html>
<head>
  <title>第五天 闭包</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/303788 (zh-CN, DDL); Windows/6.2.9200 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="828"/>
<h1>第五天 闭包</h1>

<div>
<span><div><b><span style="color: rgb(227, 0, 0);"><span style="font-size: 16px;">1.闭包</span></span></b></div><div>1)概念:</div><div>     在JS中，每个函数<span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">运行的时候</span>，都会形成一个私有空间（占用一定的浏览器内存），这个空间不会被外界打扰（这个函数自己私有的东西），这个空间就叫做<span style="color: rgb(235, 0, 115);"><span style="font-size: 15px;"><b>闭包</b></span></span>。</div><div>     ----官方定义： 闭包是指有权访问另一个函数作用域中的变量的函数。</div><div>     ----js的函数都可以称为闭包（任何一个定义在全局的函数都可以访问全局作用域）</div><div>     ----隔离性，外界访问不到其内部空间。（他自己可以访问外部，但是外部无法访问他）</div><div>2）作用：</div><div> 闭包可以用在许多地方。它的最大用处有两个，一个是前面提到的可以读取函数内部的变量（return这内部函数的引用），另一个就是让这些变量的值始终保持在内存中（闭包始终占内存）。 </div><div>3）学习闭包的意义：</div><div>     解决在外部间接访问闭包内部数据的问题</div><div>----在一般情况下，外部是无法访问到函数内部的变量的，且一般情况下函数执行完就会立即回收所占据的内存，重复执行同一个函数，不会存在内部变量的累积（‘阅后即焚’）；但是闭包就不一样了，因为他要返回一个函数的引用，而这个被引用的函数内部的私有数据也依赖于上一级作用域的变量，所以这个变量要始终存在，整个闭包的函数就不会被释放，始终占据内存 ，继续执行这个闭包函数，仍旧会在原来的基础上接着执行。</div><div>闭包的常见创建方式：</div><div>一个函数内部创建另一个函数</div><div>4）提出一个问题：</div><div>     在外边如何访问闭包内的数据？</div><div>     ---&gt;通过return返回值（错误）</div><div>               ----使用完立即销毁，不占内存，无法保存私密数据</div><div>        </div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>          function fn（）{</div><div>               var num=123;</div><div>               return num;</div><div>          }</div><div>          var ret1=fn（）;//fn的返回值赋给ret1</div><div>          alert（ret1）;</div><div>          var ret2=fn（）;//fn的返回值赋给ret2</div><div>          alert（ret2）;</div><div>          //调用两次函数，开辟两次内存，将不同的引用地址分别赋给ret1和ret2，只是值恰好相等，但是本质是不一样的</div></div><div><br/></div><div>---&gt;正确：</div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div> function foo () {</div><div>        var num = Math.random();   // 原始数据</div><div>        function func () {</div><div>            return num; // 它就是原始数据 num,通过查找机制找到func里面的num</div><div>        }</div><div>        return func;</div><div>    }</div><div>         var f = foo();     // foo 只调用一次, 只创建一个num, 但是返回的函数可以重复调用</div><div>                         // 每调用一次就是在获得闭包中的数据的值</div><div>                         //每次调用func，都是一个查找的过程，不是一个创建的过程,都是使用func的地址去调用其指向的函数</div><div>                         //f中储存的是foo函数的返回值，也就是func的地址，所以调用f()也就是调用指向func地址的函数，通过func，找到foo中的num</div><div>         var v1 = f();//函数在调用的时候并不改变该函数的作用域</div><div>         console.log( v1 );</div><div>         var v2 = f();//</div><div>         console.log( v2 );</div></div><div>5）函数作为一般数据来使用</div><div>a.<font color="#010101" face="Open Sans" size="2"><span style="font-size:10pt">可以用来赋值</span></font></div><div align="left" style="min-height: 11pt;"><div><font color="#010101" face="Open Sans" size="2"><span style="font-size:10pt">var num=fn---将函数的引用赋给num;</span></font></div><div align="left" style="min-height: 11pt;"><div><font color="#010101" face="Open Sans" size="2"><span style="font-size:10pt">var num=fn（）/直接赋给num函数表达式---将函数的返回值赋给num</span></font></div></div></div><div><span style="color: rgb(1, 1, 1);"><span style="font-family: 'Open Sans';">b.</span></span><font color="#010101" face="Open Sans" size="2"><span style="font-size:10pt">可以当作参数传递给另一个函数</span></font></div><div align="left" style="min-height: 11pt;"><div><font color="#010101" face="Open Sans" size="2"><span style="font-size:10pt">foo（fn）/foo(函数表达式)---将函数的引用作为参数</span></font></div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>function fn(callback){</div><div>     callback();</div><div>}</div><div>fn(fn2);</div><div>fn2(){};</div></div><div><br/></div></div><div><span style="font-family: 'Open Sans';"><span style="color: rgb(1, 1, 1);">c.</span></span><font color="#010101" face="Open Sans" size="2"><span style="font-size:10pt">也可以当作另一个函数的返回值</span></font></div><div align="left" style="min-height: 11pt;"><div><font color="#010101" face="Open Sans" size="2"><span style="font-size:10pt">return（fn）/return(函数表达式)---将函数的引用作为函数的返回值</span></font></div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>function fn(){</div><div>       function fn2(){}</div><div>       return fn2;</div><div>    }</div><div>    var f = fn();</div><div>    f();</div></div><div><br/></div></div><div>6）学习闭包的核心思想：</div><div>          通过返回一个函数来获取里面的数据---&gt;对数据进行增删改查</div><div>7)<span style="color: rgb(227, 0, 0);"><b><span style="font-size: 15px;">闭包的应用1</span></b></span>--函数里定义两个变量，外界如何访问？</div><div>方案一：使用数组</div><div>方案二：使用对象---&gt;我们使用对象</div><div>为什么不使用数组？        </div><div>---&gt;使用对象一对一，获取和改变更清晰；</div><div>        因为在数组中不能给函数起名，只能通过arr[i]调用，而对象中可以自定义名称调用，语义化更清楚，可以迅速找到数据。</div><div>     作用域在函数定义的时候已经决定，无法改变，除非删除重新定义。                                                      </div><div>     </div><div><br/></div><div>8）<span style="font-size: 15px;"><span style="color: rgb(227, 0, 0);"><b>闭包的应用2</b></span></span>--如何利用闭包实现访问多个数据？（如何实现私有数据？）</div><div>访问多个数据：---带有私有数据的对象</div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>function  foo(){</div><div>    var num1=12,num2=33;</div><div>    return{</div><div>        get_num1: function () {</div><div>            return num1;</div><div>        },</div><div>        get_num2: function () {</div><div>            return num2;</div><div>        },</div><div>        set_num1: function (value) {</div><div>            num1=value;</div><div>            return num1;</div><div>        }</div><div>       }</div><div>}</div><div>var f=foo();</div><div>console.log(f.get_num1());</div><div>console.log(f.get_num2());</div><div>console.log(f.set_num1(100));</div></div><div><br/></div><div>实现私有数据(本质是一样的):</div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>function createPerson(name,gender){</div><div>    var hasChanged=false;</div><div>    return{</div><div>        get_name: function () {</div><div>            return name;</div><div>        },</div><div>        get_gender: function () {</div><div>            return gender;</div><div>        },</div><div>        set_gender: function (val) {</div><div>             if(hasChanged){</div><div>                 throw new Error('别再变性啦');</div><div>             }</div><div>            else{</div><div>                 hasChanged=true;</div><div>                 gender=val;</div><div>                 return gender;</div><div>             }</div><div>        }</div><div>    }</div><div>}</div><div>var man=createPerson('张三','男');</div><div>console.log(man.get_gender());</div><div>console.log(man.get_name());</div><div>console.log(man.set_gender('女'));</div><div>console.log(man.get_gender());</div><div>console.log(man.get_name());</div><div>console.log(man.set_gender('男'));</div></div><div><br/></div><div>9）闭包的特点：</div><ul><li>保护内部变量不受外界打扰</li><li>函数执行时，形成自己的私有空间</li><li>在自己的私有作用域内访问访问变量的时候，如果自己的私有作用域内没有，就可以访问上一级的变量</li></ul><div>     利用闭包的特点，实现了访问函数中私有变量的目的</div><div><span style="color: rgb(227, 0, 0);"><b>10）闭包的核心技术：</b></span></div><div><b><span style="color: rgb(65, 173, 28);">a.带有私有数据的函数：</span></b></div><div>     他必须是某个函数的返回值；</div><div>     这个带有私有数据的函数体内要有某个函数的私有数据。</div><div><img src="第五天 闭包_files/Image.png" type="image/png" style="height: auto;"/></div><div><br/></div><div><b><span style="color: rgb(50, 135, 18);">b.带有私有数据的对象：</span></b></div><div>    有的时候，会返回很多函数，我们把它放在一个对象里面；</div><div>    这个时候，我们就叫他带有私有数据的对象。</div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>function createPerson ( name, age, gender ) {</div><div>        var hasChangeGender = false;</div><div>        // 下面的就是带有私有数据的对象</div><div>        return {</div><div>            get_Name: function () {</div><div>                return name;</div><div>            }, set_Name: function ( value ) {</div><div>                name = value;</div><div>            }, get_Age: function () {</div><div>                return age;</div><div>            }, get_Gender: function () {</div><div>                return gender;</div><div>            }, set_Gender: function ( value ) {</div><div>                if ( hasChangeGender == false ) {</div><div>                    gender = value;</div><div>                    hasChangeGender = true;</div><div>                } else {</div><div>                    throw new Error( '已经改变过一次性别了, 不能再修改了' );</div><div>                }</div><div>            }</div><div>        };</div><div>    }</div><div><br/></div><div>    var p1 = createPerson( '张三', 19, '男' );</div></div><div><br/></div><div>11）<span style="font-size: 15px;"><span style="color: rgb(227, 0, 0);"><b>闭包的应用3</b></span></span>--沙箱模式</div><div>沙箱---隔离的执行环境</div><div>有时为了代码的简洁不得不引入许多变量，但是变量过多会导致出现冲突的可能性变大----&gt;解决：沙箱模式</div><div><span style="color: rgb(50, 135, 18);">就是为了让代码载隔离的环境下运行，这个隔离的环境就是自执行函数。</span></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>//沙箱模式</div><div>（function （）{</div><div>//所有代码都在这里</div><div>}）（）;</div></div><div>优点：</div><ul><li>可以保护之前的变量名不受污染--自执行函数自动执行，不影响整个代码的执行，不需要预解释，外部访问不到内部的变量</li><li>不会改变代码的执行顺序</li></ul><div>缺点：</div><ul><li>这个自执行函数在执行完毕后不会释放，仍旧占用内存（忽略掉这个缺点）</li></ul><div>11）<b><span style="color: rgb(227, 0, 0);"><span style="font-size: 15px;">闭包的应用4</span></span></b>--简化递归</div><div>    初版：     </div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>      var count1 = 0;</div><div>      function fib1 ( n ) {</div><div>      count1++;</div><div>      if ( n == 1 || n == 0 ) return 1;</div><div>        return fib1( n - 1 ) + fib1( n - 2 );</div><div>      }</div></div><div><br/></div><div>改进版：</div><div style="box-sizing: border-box; padding: 8px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">// 使用闭包保护数据</span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">var fib2 = (function () {</span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">        var data = [ 1, 1 ];</span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">        return function ( n ) {</span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">            var v = data[ n ];</span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">            if ( v ) {</span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">                return v;</span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">            } else {</span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">                v = arguments.callee( n - 1 ) +</span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">                    arguments.callee( n - 2 );</span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">                data[ n ] = v;</span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">                return v;</span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">            }</span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">        };</span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">    })()</span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">    var f=fib2;</span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">    console.log(f(3));</span></span></span></div></div><div>12）<span style="font-size: 15px;"><b><span style="color: rgb(227, 0, 0);">闭包应用5</span></b></span>--onload时间追加与移除</div><div>window.onload事件--里面的代码先不执行，等后面所有的代码都执行完毕以后再返回来执行</div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>var itcastload = (function () {</div><div><br/></div><div>        // 私有数据</div><div>        var data = [];</div><div>        // 由于要求系统在调用 load 的时候, 执行这个数组中的所有方法</div><div>        // 因此需要手动实现 onload 的功能</div><div>        window.onload = function () {</div><div>            // 依次执行 数组中的 方法</div><div>            for ( var i = 0; i &lt; data.length; i++ ) {</div><div>                data[ i ]();</div><div>                console.log(data);</div><div>            }</div><div>        };</div><div><br/></div><div>        return {</div><div>            addEvent: function ( fn ) {</div><div>                data.push( fn );</div><div>            }, removeEvent: function ( fn ) {</div><div>                // 删除 fn</div><div>                // 遍历 data, 发现与 fn 相同的就删除</div><div><br/></div><div>                // 给定一个数组, 删除里面的元素</div><div>                // arr.splice( 从第几个元素开始, 一共删除多少个元素 )</div><div>                // 删除以后 arr.length 就发生变化了</div><div>                // 倒过来循环</div><div>                for ( var i = data.length - 1; i &gt;= 0; i-- ) {</div><div>                    if ( data[ i ] === fn ) {</div><div>                        data.splice( i, 1 );</div><div>                    }</div><div>                }</div><div>            }</div><div>        };</div><div><br/></div><div>    })();</div><div><br/></div><div>    itcastload.addEvent( function () {</div><div>        console.log( '我加载了1' );</div><div>    } );</div><div><br/></div><div>    function f () {</div><div>        console.log( '我加载了3' );</div><div>    }</div><div><br/></div><div>    itcastload.addEvent( f );</div><div><br/></div><div>    itcastload.addEvent( function () {</div><div>        console.log( '我加载了2' );</div><div>    } );</div><div><br/></div><div>    itcastload.removeEvent( f );</div></div><div><br/></div><div>13）<span style="font-size: 15px;"><b><span style="color: rgb(227, 0, 0);">闭包应用6</span></b></span>-模拟缓存结构--本质是一个键值对</div><div>     a.首先创建cache对象，考虑使用键值对存储数据 cache[ key ] = value；</div><div>     b.考虑缓存需要在数据达到阈值的时候清理内存，而cache = {}形式不能进行判定，进一步考虑将cache写成函数形式---函数也是对象；</div><div style="box-sizing: border-box; padding: 8px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">function cache ( key, value ) {</span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);"><br/></span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">        // 可以在这里加上限定长度的代码</span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);"><br/></span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">        cache[ key ] = value;</span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">    }</span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">cache( 'name1', '张三' );</span></span></span></div></div><div>     c.因为要记录key的数量和顺序，所以考虑使用有序的数组来实现这个功能---这样cache对象就初步带有缓存功能了</div><div>     d.在此基础上，还需要判断缓存的数量，即key的数量---data数组的长度，超出则删除，未超出不做改变</div><div>    </div><div style="box-sizing: border-box; padding: 8px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);"> var cache = (function () {</span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">         data = [], max = 3;</span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">        // 去掉 var 的目的是为了使得变量编程全局变量, 可以调试查看 data 中的数据</span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">        // 开发中不允许省略 var</span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);"><br/></span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">        function cache ( key, value ) {</span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);"><br/></span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">            // 做判断, 如果超出范围, 则, 将最开始加入的 移除</span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">            // 将数组 第 0 项元素移除的 splice, shift</span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">            if ( data.length &gt;= 3 ) {</span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">                // 需要先移除</span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">                var temp = data.shift();</span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">                delete cache[ temp ];</span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">            }</span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);"><br/></span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">            data.push( key );</span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);"><br/></span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">            cache[ key ] = value;</span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">        }</span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">        return cache;</span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">    })();</span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);"><br/></span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">    cache( 'name1', '张三' );</span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">    cache( 'name2', '李四' );</span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">    cache( 'name3', '王五' );</span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">    cache( 'name4', '找钱' );</span></span></span></div></div><div>     e.考虑到在实际开发中药多次使用缓存结构，所以如下改写代码，需要使用，就调用一次。</div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>    function createCache () {</div><div>        var data = [], max = 3;</div><div>        // 去掉 var 的目的是为了使得变量编程全局变量, 可以调试查看 data 中的数据</div><div>        // 开发中不允许省略 var</div><div><br/></div><div>        function cache ( key, value ) {</div><div><br/></div><div>            // 做判断, 如果超出范围, 则, 将最开始加入的 移除</div><div>            // 将数组 第 0 项元素移除的 splice, shift</div><div>            if ( data.length &gt;= 3 ) {</div><div>                // 需要先移除</div><div>                var temp = data.shift();//shift会返回删除的元素</div><div>                delete cache[ temp ];//删除了data数组中记录的key值，还需要从cache对象中彻底删除这个key值</div><div>            }</div><div><br/></div><div>            data.push( key );//data中存入key值</div><div><br/></div><div>            cache[ key ] = value;//将key对应的value存入cache对象中</div><div>        }</div><div>        return cache;</div><div>    }</div><div><br/></div><div>    var kvCache = createCache();</div></div><div><br/></div><div><br/></div><div><img src="第五天 闭包_files/Image [1].png" type="image/png" style="height: auto;"/></div><div><br/></div><div><img src="第五天 闭包_files/Image [2].png" type="image/png" style="height: auto;"/></div></span>
</div></body></html> 