<html>
<head>
  <title>第三天 面向对象3</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/303788 (zh-CN, DDL); Windows/6.2.9200 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="600"/>
<h1>第三天 面向对象3</h1>

<div>
<span><div><span style="font-size: 21px;"><b><span style="color: rgb(227, 0, 0);">动态函数 new Function：</span></b></span></div><div align="left" style="min-height: 11pt;"><div><font color="#010101" face="Open Sans" size="2"><span style="font-size:10pt">概念：动态函数：<span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">将一段字符串作为代码运行</span>，该字符串可以随意拼接，故实现了动态执行。</span></font></div><div><font color="#010101" face="Open Sans">语法：a.使用</font><font color="#010101" face="Open Sans" size="2"><span style="font-size:10pt">构造函数Function；</span></font></div><div><span style="font-family: 'Open Sans';"><span style="color: rgb(1, 1, 1);">          b.</span></span><font color="#010101" face="Open Sans" size="2"><span style="font-size:10pt">将构造函数实例化并写入形参：</span></font></div><div><span style="font-family: 'Open Sans';"><span style="color: rgb(1, 1, 1);">               new Function（形参1，形参2，...，函数体）；</span></span></div><div><span style="font-family: 'Open Sans';"><span style="color: rgb(1, 1, 1);">               注意：1.如果只传入一个参数，那么这个参数就是函数体；</span></span></div><div><span style="font-family: 'Open Sans';"><span style="color: rgb(1, 1, 1);">                         2.如果传入多个参数，那么最后一个是函数体，其他的都是形参<br/></span></span></div><div><span style="font-family: 'Open Sans';"><span style="color: rgb(1, 1, 1);">                         3.这些参数都必须是字符串(加引号)</span></span></div><div>                         <span style="color: rgb(1, 1, 1);"><span style="font-family: 'Open Sans';">4.函数体可以采用拼接字符串的形式</span></span></div><div><span style="font-family: 'Open Sans';"><span style="color: rgb(1, 1, 1);">                           -----采用普通的'++'形式；</span></span></div><div><span style="font-family: 'Open Sans';"><span style="color: rgb(1, 1, 1);">                           -----采用template模板，把要执行的代码直接放到模板里，直接得到字符串</span></span></div><div>                         <span style="color: rgb(1, 1, 1);"><span style="font-family: 'Open Sans';">5.没有传参即创建了一个空函数</span></span></div><div><span style="font-family: 'Open Sans';"><span style="color: rgb(1, 1, 1);">          c.调用（传入实参）。</span></span></div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>var getSum2 = new Function ( 'num1', 'num2', 'return num1 + num2;' );</div><div>getSum2( 1235, 678 )；</div></div><div><br/></div></div><div>补充：json格式：</div><div>1.国际通用格式：</div><div>{‘name’:'itcast','age':'19'}</div><div>   国际通用json格式字符串：</div><div>'{‘name’:'itcast','age':'19'}'</div><div>2.JS中的json：</div><div>{name:'itcast',age:'19'}</div><div><span style="color: rgb(227, 0, 0);"><span style="font-size: 21px;"><b>函数相关参数：</b></span></span></div><div><span style="color: rgb(235, 0, 115);"><span style="font-size: 15px;"><i><b>1.arguements--‘’伪数组‘’（实参列表）</b></i></span></span></div><div>凡是函数调用, 都会默认含有一个 arguments <span style="color: rgb(65, 173, 28);"><b>对象</b></span>. 可以将其看做为 &quot;数组&quot;. 里面存储着调用时传入的所有参数. 可以使用数组的索引访问这些参数.</div><div><span style="color: rgb(26, 144, 185);"><b>注意：</b></span></div><ul><li>函数调用时，arguments接收的是所有的<span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">实参</span>，他的形式是一个<span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">伪数组</span>；</li><li>不管也不写形参，形参的个数和arguments也没有什么关系，不影响他的使用；</li><li>构造函数也是有arguments的；</li><li>使用arguments将extend函数改写</li></ul><div>          extend---有则覆盖，无则添加</div><div><img src="第三天 面向对象3_files/Image.png" type="image/png" style="height: auto;"/>          </div><div><span style="font-size: 15px;"><i><span style="color: rgb(235, 0, 115);"><b>2.函数名.length</b></span></i></span></div><div>     函数的length 属性. 表示定义函数时,形参的个数</div><div>     定义形参.调用未传实参.该参数在函数内就是 undefined；</div><div><span style="font-size: 15px;"><span style="color: rgb(235, 0, 115);"><i><b>3.函数.name</b></i></span></span></div><div>     返回的是函数名---name里实际储存的是函数的引用（地址）。</div><div>     匿名函数也是可以打印出函数名的，只不过为一个空字符串。</div><div>     </div><div><br/></div><div style="box-sizing: border-box; padding: 8px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">(function(){</span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">    alert(&quot;aaaa&quot;);</span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">})();</span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">console.log(function(){</span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">    alert(&quot;aaaa&quot;);</span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">}.name);//空字符串</span></span></span></div></div><div><span style="color: rgb(227, 0, 0);"><span style="font-size: 21px;"><b>函数的引用 callee 与 caller</b></span></span></div><div>        在函数内部，有两个特殊的对象：arguments 和 this。其中， arguments 的主要用途是保存函数参数（实参）， 但这个对象还有一个名叫 callee 的属性，该属性是一个指针，指向拥有这个 arguments 对象的函数。<br/></div><div><span style="color: rgb(235, 0, 115);"><span style="font-size: 15px;"><b>callee---被调用的函数（被动</b>）</span></span></div><div>语法：arguments.callee</div><div>用途：可以代替传统递归方法，实现函数的递归</div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>传统：</div><div>function fn(){</div><div>    fn();</div><div>}</div><div>fn();</div><div>callee实现的递归：</div><div>function fn(){</div><div>    arguments.callee();</div><div>}</div><div>fn();</div></div><div><span style="font-size: 15px;"><span style="color: rgb(235, 0, 115);"><b><br/></b></span></span></div><div><span style="font-size: 15px;"><span style="color: rgb(235, 0, 115);"><b>caller---发起调用的函数（主动）----低版本浏览器不支持</b></span></span></div><div>语法：函数名.caller</div><div>和函数在哪里定义没有关系，只和在哪里调用有关系</div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>     function f1 () {</div><div>       f2();</div><div>       console.log(arguments.callee);</div><div>      }</div><div>       function f2(){</div><div>         console.log('222');</div><div>         console.log(f2.<span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">caller</span>);</div><div>     }</div><div>      f1();</div><div>    // f1 就是称为调用者. 调用的发起人.---caller</div><div>    // f2 就是被调用者---callee</div></div><div>想要打印出caller:</div><div>1. 被调用函数的执行是在调用函数体内;</div><div>2. 在被调用函数中打印才可以。</div><div><br/></div><div><b><span style="font-size: 21px;"><span style="color: rgb(227, 0, 0);">eval()函数</span></span></b></div><div>    作用：<span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">把字符串当做js代码执行</span></div><div>    语法：eval（“代码”）；</div><div>               ----示例：</div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>    eval( 'var num = 123;' );</div><div>    eval( 'console.log( num );' );</div></div><div><br/></div><div>    应用：将json格式的字符串转换成对象，这个时候要加括号！--变成一个包含括号形式的字符串</div><div>    <span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">为什么要加括号：</span></div><ol><li>不加括号会当成代码块执行，{}只是当成一个限定范围的东西；</li><li>{}用来限定范围之后，里面的内容会被当成代码块执行，而不是当成对象，例如：出现，：等报错是因为当做代码执行后，这样的符号是不符合代码规范的。</li></ol><div>     </div><div>          代码演示：</div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>console.log(eval('{name:&quot;小李&quot;}'));</div><div>console.log(eval('({name:&quot;小李&quot;})'));</div><div>var json = '{&quot;name&quot;: &quot;itcast&quot;, &quot;age&quot;: 10}';</div><div>var obj =eval('('+json+')');</div></div><div>          输出结果：</div><div>          <img src="第三天 面向对象3_files/Image [1].png" type="image/png" style="height: auto;"/></div><div><span style="font-size: 21px;"><span style="color: rgb(227, 0, 0);"><b>Function（）</b></span></span></div><div>     JS中，任何函数是Function 的实例（没有例外情况）</div><div>     任何一个构造函数都另外有两个身份：函数和对象，所以就有prototype和__proto__两个属性。</div><div>   eg：</div><div>           构造函数Student    ---看做函数：有实例，prototype属性</div><div>                                       ---看做对象：有构造函数，是该构造函数的实例，有__proto__属性</div><div>                                                            所以他是Function函数的一个实例，Student.__proto__--- &gt;Function.prototype</div><div>           Function也是自己的一个实例，也是自己的构造函数</div><div>          构造函数Function  ---看做构造函数：有实例，prototype属性；</div><div>                                       ---看做对象：Function也是一个函数，同时也是一个对象，满足任何函数都是Function的一个实例这个准则，所以自己是自己的实例，有__proto__,有prototype两个属性（’一人分饰两角‘）。</div><div><span style="color: rgb(235, 0, 115);"><span style="font-size: 16px;"><i><b>区分：</b></i></span></span></div><div><span style="font-size: 15px;"><i><span style="color: rgb(65, 173, 28);"><b>-----&gt;任何对象（除了通过构造函数实例化的）都是Object的实例</b></span></i></span></div><div><i><b><span style="font-size: 15px;"><span style="color: rgb(65, 173, 28);">Function可以是自己的一个实例，但是Object.prototype却不可以，因为循环指向自己无意义。</span></span></b></i></div><div><span style="font-size: 19px;"><span style="color: rgb(227, 0, 0);"><b>牢记函数的三个身份：</b></span></span></div><div>（他的三个身份之间互不影响）</div><div>    1. 是一个普通函数，可以直接执行。</div><div>    2. 是一个构造函数，可以用来new 一个实例。</div><div>    3. 是一个对象，（我们可以将他当成一个普通的对象来看待）</div><div><span style="font-size: 21px;"><span style="color: rgb(227, 0, 0);"><b>Function（）和eval()的区别：</b></span></span></div><div><b><span style="font-size: 21px;"><span style="color: rgb(227, 0, 0);"><br/></span></span></b></div><table style="-evernote-table:true;border-collapse:collapse;table-layout:fixed;margin-left:0px;width:100%;"><tbody><tr><td style="border-style:solid;border-width:1px;border-color:rgb(211,211,211);padding:10px;margin:0px;width:25.759999999999998%;"><div>方法名</div></td><td style="border-style:solid;border-width:1px;border-color:rgb(211,211,211);padding:10px;margin:0px;width:25.119999999999997%;"><div>作用域</div></td><td style="border-style:solid;border-width:1px;border-color:rgb(211,211,211);padding:10px;margin:0px;width:24.8%;"><div>语法机制</div></td><td style="border-style:solid;border-width:1px;border-color:rgb(211,211,211);padding:10px;margin:0px;width:24.16%;">联系</td></tr><tr><td style="border-style:solid;border-width:1px;border-color:rgb(211,211,211);padding:10px;margin:0px;width:25%;"><div>eval（）</div></td><td style="border-style:solid;border-width:1px;border-color:rgb(211,211,211);padding:10px;margin:0px;width:25%;"><div>任何作用域下生效</div></td><td style="border-style:solid;border-width:1px;border-color:rgb(211,211,211);padding:10px;margin:0px;width:25%;"><div>相对简单：</div><div>eval（“代码”）；</div><div>           --直接执行</div></td><td style="border-style:solid;border-width:1px;border-color:rgb(211,211,211);padding:10px;margin:0px;width:25%;"><div><br/></div></td></tr><tr><td style="border-style:solid;border-width:1px;border-color:rgb(211,211,211);padding:10px;margin:0px;width:25%;"><div>Function（）</div></td><td style="border-style:solid;border-width:1px;border-color:rgb(211,211,211);padding:10px;margin:0px;width:25%;"><div>只在自己创建的私有作用域生效</div></td><td style="border-style:solid;border-width:1px;border-color:rgb(211,211,211);padding:10px;margin:0px;width:25%;"><div>相对简单：</div><ol><li>先创建构造函数，</li><li>再生成实例对象，传入实参（全是字符串型：实参1，实参2，，，，函数体）</li><li>调用</li></ol></td><td style="border-style:solid;border-width:1px;border-color:rgb(211,211,211);padding:10px;margin:0px;width:25%;"><div>都是把括号内的字符串当做代码执行</div></td></tr></tbody></table><div><b><span style="font-size: 21px;"><span style="color: rgb(227, 0, 0);"><br/></span></span></b></div><div><span style="font-size: 21px;"><span style="color: rgb(227, 0, 0);"><b>instanceof 运算符</b></span></span></div><div>          错觉: 判断某一个对象是否为某一个构造函数所创建出来的</div><div>          真：判断新的原型属性是否在这个实例的原型链上</div><div>          因为一般我们不改变原型属性的指向，所以在默认不修改其指向的情况下，我们可以使用它来检测这个对象是否是构造函数的实例</div><div><img src="第三天 面向对象3_files/Image [2].png" type="image/png" style="height: auto;"/></div><div>不会随意更改构造函数的原型属性，只会在链上添加对象，或者使用混入</div><div><span style="font-size: 21px;"><span style="color: rgb(227, 0, 0);"><b>其他方法的了解</b></span></span></div><div>      call()--只能由函数调用，是一个方法----&gt;改变函数中的this指向</div><div>     Object.prototype.toString.call()--&gt;判断数据类型最可靠的方法</div><div>     .constructor---判断其构造函数的指向---&gt;帮助检测数据类型</div><div><img src="第三天 面向对象3_files/Image [3].png" type="image/png" style="height: auto;"/></div></span>
</div></body></html> 